(this.webpackJsonpsorting=this.webpackJsonpsorting||[]).push([[0],[,,,,,,,,,function(e,t,n){e.exports=n(21)},,,,,function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){},function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),o=n(3),i=n.n(o),s=(n(14),n(1)),l=n(4),h=n(5),c=n(7),u=n(6),p=n(8);n(15);function g(e){if(e.length<=1)return e;var t=e.slice(),n=[];return function e(t,n,a,r,o){if(n===a)return;var i=Math.floor((n+a)/2);e(r,n,i,t,o),e(r,i+1,a,t,o),function(e,t,n,a,r,o){var i=t,s=t,l=n+1;for(;s<=n&&l<=a;)o.push([s,l]),o.push([s,l]),r[s]>r[l]?(o.push([i,r[l]]),e[i]=r[l],i++,l++):(o.push([i,r[s]]),e[i]=r[s],i++,s++);for(;s<=n;)o.push([s,s]),o.push([s,s]),o.push([i,r[s]]),e[i]=r[s],i++,s++;for(;l<=a;)o.push([l,l]),o.push([l,l]),o.push([i,r[l]]),e[i]=r[l],i++,l++}(t,n,i,a,r,o)}(e,0,e.length-1,t,n),n}function m(e){var t=[];return function e(t,n,a,r){if(a<r){var o=function(e,t,n,a){for(var r=t[a],o=n-1,i=n;i<=a-1;i++)if(e.push([i,a]),e.push([i,a]),t[i]<r){o++,e.push("Swap"),e.push([o,t[i],i,t[o]]);var s=t[o];t[o]=t[i],t[i]=s}s=t[o+1];return e.push("Swap"),e.push([o+1,t[a],a,t[o+1]]),t[o+1]=t[a],t[a]=s,o+1}(t,n,a,r);e(t,n,a,o-1),e(t,n,o+1,r)}}(t,e,0,e.length-1),t}function d(e,t,n,a){var r=a,o=2*a+1,i=2*a+2;if(o<n&&(e.push([o,r]),e.push([o,r]),t[o]>t[r]&&(r=o)),i<n&&(e.push([i,r]),e.push([i,r]),t[i]>t[r]&&(r=i)),r!==a){e.push("Swap"),e.push([a,t[r],r,t[a]]);var s=t[a];t[a]=t[r],t[r]=s,d(e,t,n,r)}}n(16),n(17),n(18),n(19);var f=!1,y=0,b=0,w=1,v=function(e){function t(e){var n;return Object(l.a)(this,t),(n=Object(c.a)(this,Object(u.a)(t).call(this,e))).state={array:[]},n}return Object(p.a)(t,e),Object(h.a)(t,[{key:"componentDidMount",value:function(){this.initializeArray()}},{key:"initializeArray",value:function(){for(var e=[],t=1;t<101;t++)e.push(5.4*t);this.setState({array:e})}},{key:"resetArray",value:function(){if(!f){var e=this.state.array;this.resetColor(),this.shuffle(e),this.setState({array:e})}}},{key:"resetColor",value:function(){for(var e=document.getElementsByClassName("array-bar"),t=0;t<e.length;t++)e[t].style.backgroundColor="cyan"}},{key:"sortWithOutSwap",value:function(e){if(!f){f=!0,this.resetColor();var t=[],n=0;this.changeSpeedFactor(),"mergeSort"===e&&(t=g(this.state.array),n=3.6),"insertionSort"===e&&(t=function(e){for(var t=[],n=1;n<e.length;n++){for(var a=e[n],r=n-1;r>=0&&e[r]>a;)t.push([n,r]),t.push([n,r]),e[r+1]=e[r],t.push([r+1,e[r]]),r--;t.push([n,r+1]),t.push([n,r+1]),e[r+1]=a,t.push([r+1,a])}return t}(this.state.array),n=1);for(var a=function(e){var a=document.getElementsByClassName("array-bar");if(e%3===0){var r=Object(s.a)(t[e],2),o=r[0],i=r[1],l=a[o],h=a[i];setTimeout((function(){l.style.backgroundColor="black",h.style.backgroundColor="black"}),e*n*b)}else if(e%3===1){var c=Object(s.a)(t[e],2),u=c[0],p=c[1],g=a[u],m=a[p];setTimeout((function(){g.style.backgroundColor="cyan",m.style.backgroundColor="cyan"}),e*n*b)}else{var d=Object(s.a)(t[e],2),y=d[0],w=d[1],v=a[y];setTimeout((function(){if(v.style.height="".concat(w,"px"),e==t.length-1){for(var n=0;n<a.length;n++)a[n].style.backgroundColor="chartreuse";f=!1}}),e*n*b)}},r=0;r<t.length;r++)a(r)}}},{key:"sortWithSwap",value:function(e){if(!f){f=!0,this.resetColor();var t=[],n=0;this.changeSpeedFactor(),"bubbleSort"===e&&(t=function(e){for(var t=[],n=!1,a=0;a<e.length-1;a++){for(var r=0;r<e.length-a-1;r++)if(t.push([r,r+1]),t.push([r,r+1]),e[r]>e[r+1]){t.push("Swap"),t.push([r,e[r+1],r+1,e[r]]);var o=e[r];e[r]=e[r+1],e[r+1]=o,n=!0}if(!n)break}return t}(this.state.array),n=.6),"heapSort"===e&&(t=function(e){for(var t=[],n=e.length/2-1;n>=0;n--)d(t,e,e.length,n);for(var a=e.length-1;a>=0;a--){t.push("Swap"),t.push([0,e[a],a,e[0]]);var r=e[0];e[0]=e[a],e[a]=r,d(t,e,a,0)}return t}(this.state.array),n=2),"quickSort"===e&&(t=m(this.state.array),n=2.7),"selectionSort"===e&&(t=function(e){for(var t=[],n=0;n<e.length-1;n++){for(var a=n,r=n+1;r<e.length;r++)t.push([a,r]),t.push([a,r]),e[r]<e[a]&&(a=r);t.push("Swap"),t.push([a,e[n],n,e[a]]);var o=e[n];e[n]=e[a],e[a]=o}return t}(this.state.array),n=.7),"cocktailShakerSort"===e&&(t=function(e){for(var t=[],n=0,a=e.length-1,r=!0;r;){r=!1;for(var o=n;o<a;o++)if(t.push([o,o+1]),t.push([o,o+1]),e[o]>e[o+1]){t.push("Swap"),t.push([o,e[o+1],o+1,e[o]]);var i=e[o];e[o]=e[o+1],e[o+1]=i,r=!0}if(!r)break;r=!1;for(var s=--a-1;s>=n;s--)if(t.push([s,s+1]),t.push([s,s+1]),e[s]>e[s+1]){t.push("Swap"),t.push([s,e[s+1],s+1,e[s]]);var l=e[s];e[s]=e[s+1],e[s+1]=l,r=!0}n++}return t}(this.state.array),n=.55),"shellSort"===e&&(t=function(e){for(var t=[],n=Math.floor(e.length/2);n>0;n=Math.floor(n/2)){console.log(n);for(var a=n;a<e.length;a++)for(var r=a;r>=n&&(t.push([r,r-n]),t.push([r,r-n]),e[r-n]>e[r]);r-=n){t.push("Swap"),t.push([r,e[r-n],r-n,e[r]]);var o=e[r];e[r]=e[r-n],e[r-n]=o}}return t}(this.state.array),n=2.3);for(var a=function(e){var a=document.getElementsByClassName("array-bar");if(e%2===0)if("Swap"!==t[e]){var o=Object(s.a)(t[e],2),i=o[0],l=o[1],h=a[i],c=a[l];setTimeout((function(){h.style.backgroundColor="black",c.style.backgroundColor="black"}),e*n*b)}else{e++;var u=Object(s.a)(t[e],4),p=u[0],g=u[1],m=u[2],d=u[3],y=a[p],w=a[m];setTimeout((function(){if(y.style.height="".concat(g,"px"),w.style.height="".concat(d,"px"),e==t.length-1){for(var n=0;n<a.length;n++)a[n].style.backgroundColor="chartreuse";f=!1}}),e*n*b)}else{var v=Object(s.a)(t[e],2),k=v[0],S=v[1],C=a[k],E=a[S];setTimeout((function(){if(C.style.backgroundColor="cyan",E.style.backgroundColor="cyan",e==t.length-1){for(var n=0;n<a.length;n++)a[n].style.backgroundColor="chartreuse";f=!1}}),e*n*b)}r=e},r=0;r<t.length;r++)a(r)}}},{key:"changeSpeedFactor",value:function(){var e=document.getElementById("myRange");b=1/e.value}},{key:"bubbleSort",value:function(){this.sortWithSwap("bubbleSort")}},{key:"heapSort",value:function(){this.sortWithSwap("heapSort")}},{key:"quickSort",value:function(){this.sortWithSwap("quickSort")}},{key:"selectionSort",value:function(){this.sortWithSwap("selectionSort")}},{key:"cocktailShakerSort",value:function(){this.sortWithSwap("cocktailShakerSort")}},{key:"mergeSort",value:function(){this.sortWithOutSwap("mergeSort")}},{key:"insertionSort",value:function(){this.sortWithOutSwap("insertionSort")}},{key:"shellSort",value:function(){this.sortWithSwap("shellSort")}},{key:"refreshPage",value:function(){window.location.reload()}},{key:"openHelpMenu",value:function(){var e=document.getElementById("helpMenu");e.style.display="block";var t=document.getElementById("info-button"),n=document.getElementsByClassName("close")[0];console.log(e,t,n),n.onclick=function(){e.style.display="none"},window.onclick=function(t){t.target==e&&(e.style.display="none")},this.changeText(1)}},{key:"openAlgoMenu",value:function(e){var t=document.getElementById("algo-modal");t.style.display="block",document.getElementsByClassName("algo-close")[0].onclick=function(){t.style.display="none"},window.onclick=function(e){e.target==t&&(t.style.display="none")},document.getElementById("algo-modal-content").innerHTML=function(e){switch(e){case 0:return'<br> <span style = "color: cyan; font-size: 200%;"> <strong><u>Bubble Sort</u></strong></span> \n                <br>\n                <br/>\n                <p>This is one of the simplest sorting algorithms. We simply iterate over the array,\n                checking each adjacent pair of values and swapping them if out of order. After each iteration,\n                the largest value would have "bubbled" to the right, hence the name Bubble sort. Thus, at the\n                end of all iterations, the array is in sorted order.</p>\n\n                <p><strong><u> Runtime: </u> </strong></p>\n                <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n                <tr>\n                <th>Best Case</th>\n                <th>Average Case</th>\n                <th>Worst Case</th>\n                </tr>\n                <tr>\n                <th>O(n) </th>\n                <th>O(n^2)</th>\n                <th>O(n^2)</th>\n                </tr>\n                </table>\n\n                <p>Note: To get O(n) best case runtime, we need to initialize a boolean to false, and if any \n                swap occurs during the first iteration, we set it to true. If the boolean is still false, this\n                means the array is already sorted and we exit. Otherwise, continue bubble sort normally.</p>\n\n                <p> O(n^2) comes from the double for loop. You can think of this as having the following number\n                of total comparisions:\n                n + n-1 + ... + 2 + 1 = n(n+1)/2 = O(n^2).</p></p>\n\n                <p><strong><u>Code: (in JavaScript)</u></strong></p>\n                <img src="https://i.imgur.com/WLNFw0J.png" alt="" width="60%" height="40%"></img>\n                ';case 1:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Selection Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>We simply find the minimum value in the entire array, and place it at the start. \n        We iterate this process for the remaining n-1 elements. (then n-2, n-3, ... 1 elements)\n         So after we iterate through the entire array, it is sorted.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>O(n^2) comes from the double for loop. You can think of this as having the following number\n        of total comparisions:\n        n + n-1 + ... + 2 + 1 = n(n+1)/2 = O(n^2).</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/2ToyycQ.png" alt="" width="50%" height="43%"></img>\n        ';case 2:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Insertion Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is how we sort our hand in card games. We iterate over the array, and for each\n        element at index i, we place it at some index j, where <br> 0 <= j <= i such that the sub array \n        from indices 0...i-1,i is sorted. Thus at the end of all iterations, the entire array is sorted.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(n)</th>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>O(n) best case is because if the array is already sorted, we will never enter the inner while loop,\n        so Insertion Sort is just a for loop iterating over the array. O(n^2) worst case comes from the \n        number of executions of the inner while loop, which is up to i times. (j = i-1 to j = 0) You can think of this as having the following number\n        of total comparisions:\n        1 + 2 + 3 + ... + n-1 + n = n(n+1)/2 = O(n^2). </p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/68lstzn.png" alt="" width="50%" height="43%"></img>\n        ';case 3:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Merge Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is a simple example of a Divide and Conquer algorithm. If the array has size 1, it is sorted \n        and we return it. Otherwise, we divide the array by half, and sort each half by Merge Sort. We then\n        have two individually sorted half arrays, and now we merge them into a final sorted array.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        </tr>\n        </table>\n\n        <p>Since Merge Sort is recursive, it can be defined by the following recurrence relation: \n        T(n) <= 2T(n/2) +cn, where T(n) is the runtime of Merge Sort on an input of size n, and c is some positive constant.\n        The 2T(n/2) comes from the two recursive calls, and the cn from the merge step. Solving this relation with\n        substitution, we see T(n) = O(nlogn) (forgive the Abuse of Notation)</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/1H7CVWu.png" alt="" width="55%" height="45%"></img>\n        <img src="https://i.imgur.com/LMvIT6E.png" alt="" width="55%" height="80%"></img>\n        ';case 4:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Heap Sort</u></strong></span> \n        <br>\n        <br/>\n        <p> We use a binary max Heap to implement Heap Sort. A heap is a data structure that satisfies a structural property, \n        and an ordering property. A heap is a complete tree, and every parent node has value >= or <= the value of it\'s children nodes. \n        (depending on if max Heap or min Heap) So, in a max Heap the root node (at index 0) is the max value, and in a min Heap the root node is the min value.\n        A heap is commonly used to efficiently implement a priority queue. \n        <br>\n        <br>\n        The idea of Heap Sort, is to first make the given array into a Heap, by calling "buildHeap". (the first for loop)\n        After the array is a Heap, we swap the root node, which is the max value to the end of the arrayso it is now in its correct\n        place. We then call heapify on the reduced Heap to ensure it is still a Heap, so we can swap the root node again on\n        the next iteration. After n swaps, the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        </tr>\n        </table>\n        <p>Note: This is assuming distinct elements. If non-distinct elements, best case is O(n) if all elements are equal,\n        since the runtime of heapify goes from O(logn) to O(1). (since the recursive calls will never execute)</p>\n\n        <p>The first for loop (buildHeap) takes O(n) time. (since we do not call heapify of the last half of nodes, \n          which are leaves and so are already Heaps) Then, we iterate over the array and perform n calls to heapify.\n          The worst case runtime of heapify is O(logn), since a Heap is a complete tree, thus we are guaranteed a height of at\n          most logn. So the max number of recursive calls is logn, each with a constant amount of work. \n          We see the total runtime of heapSort = O(nlogn).</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/ZeA54C4.png" alt="" width="55%" height="45%"></img>\n        <img src="https://i.imgur.com/n8q8XS7.png" alt="" width="65%" height="45%"></img>\n        ';case 5:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Quick Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is another example of a Divide and Conquer algorithm, and is similar to Merge Sort. The general idea is to pick a pivot element,\n        and then partition all elements less than this pivot to the left of it, and all elements greater than the pivot to the right of it.\n        So, there are many versions of Quick Sort, that differ in how they select the pivot. In our implementation, we always pick the last element as \n        the pivot. After we perform this partitioning of the array, we then perform Quick Sort on the sub array to the left of the pivot,\n        and Quick Sort on the sub array to the right of the pivot. At the end, the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n        <p>Note: We can get O(n) best case for Quick Sort if we use "three-way partition and equal keys"</p>\n        <p>For average case, we assume the pivot will partition the array into two roughly similarly sized "halves". Let\'s say\n        for simplicity, the two "halves" have size upper bounded by 2n/3. \n        So, we can describe Quick Sort by the following recurrence relation: T(n) <= cn + 2T(2n/3), where c is some positive constant.\n        The cn comes from the runtime of "partition", and 2T(2n/3) from the two recursive calls to Quick Sort. Solving with substitution, we see\n        T(n) = O(nlogn).  </p>\n\n        <p>For worst case, this occurs when the pivot picked is always the largest or smallest element of the array.\n        Thus, one side of the partition will always be empty, reducing the efficiency of Quick Sort significantly.\n        In this case, we can model the situation by the following recurrence relation: T(n) <= cn + T(n-1) for some positive constant\n        c. T(n-1) is because we now only have one recursive call, on an array of size n-1. Solving by substitution, we see\n        T(n) = O(n^2).  \n        Alternatively, we see that the work done by partition is like n + n-1 + n-2 + ... + 2 + 1, which is = n(n+1)/2 = O(n^2) </p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/IznX2TT.png" alt="" width="55%" height="45%"></img>\n        <img src="https://i.imgur.com/fXjteJm.png" alt="" width="55%" height="60%"></img>\n        ';case 6:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Cocktail Shaker Sort</u></strong></span> \n                <br>\n                <br/>\n                <p>This is a slight modification of Bubble Sort, hence the alternative name, "Bidirectional Bubble Sort". There\n                are two "passes", the forward pass, and then the backward pass. We perform Bubble Sort on each pass, but the first pass\n                will "bubble" the largest element to the last index of the array, and then on the backward pass the smallest element will\n                be "bubbled" to the first index of the array. We increment the first index and decrement the last index, and continue this \n                process until no swaps happen, which is our termination condition as this tells us the array is sorted.</p>\n\n                <p><strong><u> Runtime: </u> </strong></p>\n                <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n                <tr>\n                <th>Best Case</th>\n                <th>Average Case</th>\n                <th>Worst Case</th>\n                </tr>\n                <tr>\n                <th>O(n) </th>\n                <th>O(n^2)</th>\n                <th>O(n^2)</th>\n                </tr>\n                </table>\n\n                <p>Runtimes are exactly the same as for Bubble Sort. Note: implementation below contains the "swapped"\n                boolean necessary for O(n) best case runtime.</p>\n\n                <p><strong><u>Code: (in JavaScript)</u></strong></p>\n                <img src="https://i.imgur.com/uL2Xgql.png" alt="" width="40%" height="74%"></img>\n                ';case 7:return'<br><span style = "color: cyan; font-size: 200%;"> <strong><u>Shell Sort</u></strong></span> \n        <br>\n        <br/>\n        <p> This is a variation on Insertion Sort. It is essentially trying to speed up Insertion Sort, since\n        insertion sort is slow when you are inserting an item far away from where it belongs. In Shell Sort, we start off by "gap insertion sorting" elements,\n        with a "gap" distance away from each other. We progressively decrease this gap using a gap sequence. \n        There are many different ways to choose gap sequences. We use a simple \n        floor(n/2), floor(n/4), ... , 1 gap sequence for simplicity. There exist more optimal gap sequences. \n        But, all gap sequences must end with 1, so that we perform Insertion Sort \n        at the very last iteration, guaranteeing the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style ="width:50%" border="3px solid black" border-collapse="collapse" align = "center">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>For best case, this is when the array is sorted, and so each step in the gap sequence takes roughly n time. \n        (innermost for loop breaks after one iteration) There are logn steps in the gap sequence by definition, so the runtime\n        is O(nlogn). \n        <br>\n        <br>\n        For worst case, we know that worst case for insertion sort is O(n^2). (Assume n is a power of 2 for simplicity)\n        So for the final iteration when gap = 1, it takes at most n^2 time. For the iteration before when gap = 2, it takes at most\n        n^2/2 time. Continuing on, we get the runtime is <= n^2(1 + 1/2 + 1/4 + ... ) = 2n^2 = O(n^2)</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src="https://i.imgur.com/aM083nL.png" alt="" width="60%" height="55%"></img>\n        ';default:return"<p>Sorry, an unexpected error occured, please refresh</p>"}}(e)}},{key:"changeText",value:function(e){switch(1==e?5===y?y=5:y+=e:1===y?y=1:y+=e,y){case 1:document.getElementById("helpMenu-content").innerHTML=this.HTMLHelper(5)+'\n        <h2 style= "margin-top: -0.3em;"> Welcome to our Sorting Algorithms Visualizer </h2> \n        <h3 style= "margin-top: -0.7em;"> Made by Eric K. and Ryan L.</h3>\n        <p> This application allows you to visualize 8 common sorting algorithms in action, while learning about their runtime and how they work! Sorting algorithms play an important role\n        in the world today, often being used to simplify other problems, and improve the complexity of solutions. Being able to understand the trade-offs between different sorting \n        algorithms, and being able to recognize which algorithm is optimal for a particular situation can drastically improve performance. Whether you are learning\n        about sorting algorithms for the first time, or are reviewing the material in preparation for an exam or interview, we hope you find this application useful \n        in your studies as a computer scientist!  \n           </p>\n        <p> Click on <strong>Next</strong> to continue the tutorial. Otherwise click anywhere outside the box, or the <strong>X</strong> button to play around with our application</p>\n        <p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;" src="https://i.imgur.com/0pmWEyQ.png" alt="" width="175" height="185" /></p>';break;case 2:document.getElementById("helpMenu-content").innerHTML=this.HTMLHelper(5)+'<h2 style= "margin-top: -0.3em;">Motivation</h2>\n        <p> We wanted to make this application because when first learning about sorting algorithms, we found it was difficult to imagine the algorithms running in our heads just looking\n        at the code. And so, we created this application where you can not only learn about common sorting algorithms, but also visualize them in a centralized platform. We hope that this\n        application will help you learn why and how these sorting algorithms work in a concise and visual manner, while having fun along the way!\n        </p>\n        <p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;" src="https://image.flaticon.com/icons/png/512/584/584641.png" alt="" width="129" height="129" /></p>';break;case 3:document.getElementById("helpMenu-content").innerHTML=this.HTMLHelper(5)+'<h2 style= "margin-top: -0.3em;"> How to Use </h2>\n        <p style = "line-height: 1.15em;"> Click the "Scramble!" button at the top bar to randomly shuffle the bars. When you are ready, click the sorting algorithm button\n        of choice on the left side of your screen. During the animations, the black bars represent the bars being compared during the execution of the sorting algorithm.\n        Once the sort is finished, the bars will turn from <span style = "color: cyan;"> <strong>cyan</strong></span> to <span style = "color: chartreuse;"> <strong>chartreuse</strong></span>! \n        <br>\n        <br> If you are interested in the runtime and code for each sorting algorithm, click on its respective info button located to its left.\n        There, you will find a high-level description, the best, average, and worst case runtimes with analysis, and the implementation code in JavaScript.\n        <br>\n        <br>\n        Feel free to use the "Sorting Speed" bar at the top, beside the "Scramble!" button. Move to the right to increase speed, and move to the left to decrease speed. If you accidentally\n        decreased the speed too much, just click on the "SORTING ALGORITHMS VISUALIZER" title to refresh the page!\n        <p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: auto;" src="https://i.imgur.com/9YYF0Zs.png" alt="" width="205" height="135" /></p>\n        <p>&nbsp;</p>\n        ';break;case 4:document.getElementById("helpMenu-content").innerHTML=this.HTMLHelper(5)+'<h2 style= "margin-top: -0.3em;"> Summary of Sorting Algorithms </h2>\n        <ol style = "text-align: left; line-height: 1.05em">\n          <li><strong>Bubble Sort</strong> - Simply checks adjacent pairs, and swaps if necessary. During each iteration, bubbles the largest value to the end of the array.</li>\n          <li><strong>Selection Sort</strong> - Finds the minimum value in the entire array[0...n-1], and places it at the beginning. Repeat for the sub array[1...n-1] until sub array has only the last element.</li>\n          <li><strong>Insertion Sort</strong> - How you sort cards in your hand. Compare until you find where each value belongs among the previous elements. </li>\n          <li><strong>Merge Sort</strong> - A Divide and Conquer algorithm, where you split the array in half and sort them recursively with Merge Sort, and then merge both sorted half arrays into one sorted array. </li>\n          <li><strong>Heap Sort</strong> - Uses a Heap data structure. Given an array, we make it into a max Heap, and then remove the root node each time and place it at the end of the array.</li>\n          <li><strong>Quick Sort</strong> - Another Divide and Conquer algorithm. We partition the array into elements less than and greater than a certain pivot, and then sort the elements less and greater than the pivot recursively with Quick Sort. </li>\n          <li><strong>Cocktail Shaker Sort</strong> - Aka Bidirectional Bubble Sort. Same thing as Bubble Sort, but we Bubble Sort going left to right, and also right to left. </li>\n          <li><strong>Shell Sort</strong> - A variant of Insertion Sort. We insertion sort by "gaps", aiming to improve on the pitfalls of Insertion Sort, which is slow when we need to insert an element far away. </li>\n          </ol>';break;case 5:document.getElementById("helpMenu-content").innerHTML=this.HTMLHelper(5)+'<h2 style= "margin-top: -0.3em;"> Last Words </h2>\n          <p> We hope you have fun with this application. Please feel free to contact any of us for feedback on the application. You\n          can also check out our Github source code at <a href = "https://github.com/ryanliu18/Sorting-Visualizer" target="_blank">Sorting Algorithms Visualizer</a> </p>          \n          <table style="height: 227px; margin-left: auto; margin-right: auto; width: 552px;">\n          <tbody>\n          <tr>\n          <td style="width: 179px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://i.ibb.co/jgZ7fF9/81928054-601968013933600-5665482190398423040-n.jpg" alt="" width="130" height="147" /></td>\n          <td style="width: 199px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://i.imgur.com/X6ou3Ig.png" alt="" width="152" height="152" /></td>\n          <td style="width: 157px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://i.ibb.co/V9qg42q/Eric-Kuo-UBC-Card.jpg" alt="" width="110" height="147" /></td>\n\n          </tr>\n          <tr>\n          <td style="width: 179px; text-align: center;"><a href="https://www.linkedin.com/in/ryan-liu18/" target = "_blank">LinkedIn Ryan Liu</a></td>\n          <td style="width: 199px; text-align: center;">&nbsp;</td>\n          <td style="width: 157px; text-align: center;"><a href="https://www.linkedin.com/in/eric-k-1198b6192/" target = "_blank">LinkedIn Eric Kuo</a></td>\n          </tr>\n          </tbody>\n          </table>\n        '}var t=document.getElementById("Prev"),n=document.getElementById("Next");1===y?(t.style.backgroundColor="lightgrey",t.disabled=!0):5===y?(n.disabled=!0,n.style.backgroundColor="lightgrey"):(console.log("reached here"),t.disabled=!1,t.style.backgroundColor="hsl(214, 100%, 70%)",n.disabled=!1,n.style.backgroundColor="hsl(214, 100%, 70%)")}},{key:"HTMLHelper",value:function(e){return"<p> "+y+"/"+e+"<p>\n  "}},{key:"updateSlider",value:function(){var e=document.getElementById("myRange"),t=document.getElementById("sliderValue");f&&(e.value=w),e.value=e.value,w=e.value,t.innerHTML="Speed: "+e.value+"x",console.log(e.value)}},{key:"render",value:function(){var e=this,t=this.state.array;return r.a.createElement(r.a.Fragment,null,r.a.createElement("div",{className:"title-container"},r.a.createElement("div",{className:"title",onClick:function(){return e.refreshPage()}},"Sorting Algorithms Visualizer!"),r.a.createElement("div",{className:"title-button-row"},r.a.createElement("button",{id:"info-button",className:"info-button",onClick:function(){return e.openHelpMenu()}}," ","?"," "),r.a.createElement("button",{onClick:function(){return e.resetArray()}}," Scramble! ")),r.a.createElement("div",{className:"slidercontainer"},r.a.createElement("input",{type:"range",min:.1,max:10,step:.01,defaultValue:w,className:"slider",id:"myRange",onChange:function(){return e.updateSlider()}})),r.a.createElement("span",{id:"sliderValue",className:"sliderValue"}," Speed: ",w,"x")),r.a.createElement("div",{id:"helpMenu",className:"modal"},r.a.createElement("div",{className:"modal-container"},r.a.createElement("span",{id:"close",className:"close"},"\xd7"),r.a.createElement("div",{className:"buttons-container"},r.a.createElement("div",{className:"info-buttons"},r.a.createElement("button",{id:"Prev",onClick:function(){return e.changeText(-1)}}," ","Prev"," "),r.a.createElement("button",{id:"Next",onClick:function(){return e.changeText(1)}}," ","Next"," ")))),r.a.createElement("div",{id:"helpMenu-content",className:"modal-content"})),r.a.createElement("div",{id:"algo-modal",className:"algo-modal"},r.a.createElement("span",{id:"algo-close",className:"algo-close"},"\xd7"),r.a.createElement("div",{id:"algo-modal-content",className:"algo-modal-content"})),r.a.createElement("div",{className:"container"},r.a.createElement("div",{className:"algo-btn-group"},r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(0)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(1)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(2)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(3)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(4)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(5)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(6)}}," \u24d8 "),r.a.createElement("button",{onClick:function(){return e.openAlgoMenu(7)}}," \u24d8 ")),r.a.createElement("div",{className:"btn-group"},r.a.createElement("button",{onClick:function(){return e.bubbleSort()}}," Bubble Sort"),r.a.createElement("button",{onClick:function(){return e.selectionSort()}}," Selection Sort"),r.a.createElement("button",{onClick:function(){return e.insertionSort()}}," Insertion Sort"),r.a.createElement("button",{onClick:function(){return e.mergeSort()}}," Merge Sort"),r.a.createElement("button",{onClick:function(){return e.heapSort()}}," Heap Sort"),r.a.createElement("button",{onClick:function(){return e.quickSort()}}," Quick Sort"),r.a.createElement("button",{onClick:function(){return e.cocktailShakerSort()}}," Cocktail Shaker Sort"),r.a.createElement("button",{onClick:function(){return e.shellSort()}}," Shell Sort")),r.a.createElement("div",{className:"array-container"},t.map((function(e,t){return r.a.createElement("div",{className:"array-bar",key:t,style:{height:"".concat(e,"px")}})})))))}},{key:"getRandomInt",value:function(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e+1))+e}},{key:"shuffle",value:function(e){for(var t=e.length-1;t>0;t--){var n=Math.floor(Math.random()*(t+1)),a=[e[n],e[t]];e[t]=a[0],e[n]=a[1]}}}]),t}(r.a.Component);n(20);var k=function(){return document.title="Sorting",r.a.createElement("div",{className:"App"},r.a.createElement(v,null))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));i.a.render(r.a.createElement(k,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}],[[9,1,2]]]);
//# sourceMappingURL=main.1bdfd9a4.chunk.js.map