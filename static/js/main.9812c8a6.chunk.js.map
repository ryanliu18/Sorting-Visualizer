{"version":3,"sources":["SortingAlgorithms/mergeSort.js","SortingAlgorithms/quickSort.js","SortingAlgorithms/heapSort.js","SortingVisualizer/SortingVisualizer.jsx","SortingAlgorithms/insertionSort.js","SortingAlgorithms/bubbleSort.js","SortingAlgorithms/selectionSort.js","SortingAlgorithms/cocktailShaker.js","SortingAlgorithms/shellSort.js","SortingAlgorithms/AlgorithmInfo.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","length","auxArray","slice","animations","mergeSortHelper","mainArray","startIdx","endIdx","midIdx","Math","floor","k","i","j","push","merge","getQuickSortAnimations","quickSort","partitionIdx","pivot","temp","partition","heapify","sizeOfHeap","rootIdx","largestOfRootAndChildrenIdx","leftChildIdx","rightChildIdx","isRunning","slideNumber","SPEED_FACTOR","DEFAULT_VALUE","SortingVisualizer","props","state","this","initializeArray","NUM_OF_BARS","setState","resetColor","shuffle","allBars","document","getElementsByClassName","style","backgroundColor","algorithm","ANIMATION_SPEED","changeSpeedFactor","currKey","getInsertionSortAnimations","firstBarIdx","secondBarIdx","firstBar","secondBar","setTimeout","newHeight","height","swapped","getBubbleSortAnimations","getHeapSortAnimations","min_idx","getSelectionSortAnimations","getCocktailShakerSortAnimations","gap","console","log","getShellSortAnimations","newHeight1","newHeight2","slider","getElementById","value","sortWithSwap","sortWithOutSwap","window","location","reload","modal","display","btn","span","onclick","event","target","changeText","info","innerHTML","displayAlgorithmInfo","next","HTMLHelper","prevBtn","nextBtn","disabled","MAXSLIDE","sliderValue","className","onClick","refreshPage","id","openHelpMenu","resetArray","type","min","max","step","defaultValue","onChange","updateSlider","openAlgoMenu","bubbleSort","selectionSort","insertionSort","mergeSort","heapSort","cocktailShakerSort","shellSort","map","idx","key","ceil","random","React","Component","App","title","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+WAAO,SAASA,EAAuBC,GAEnC,GAAIA,EAAMC,QAAU,EAAG,OAAOD,EAC9B,IAAME,EAAWF,EAAMG,QACjBC,EAAa,GAGpB,OAKH,SAASC,EAAgBC,EAAUC,EAASC,EAAON,EAASE,GACxD,GAAIG,IAAaC,EAAQ,OACzB,IAAMC,EAASC,KAAKC,OAAOJ,EAAWC,GAAQ,GAC9CH,EAAgBH,EAASK,EAASE,EAAOH,EAAUF,GACnDC,EAAgBH,EAASO,EAAO,EAAED,EAAOF,EAAUF,GAOvD,SAAeE,EAAUC,EAASE,EAAOD,EAAON,EAASE,GACrD,IAAIQ,EAAIL,EACJM,EAAIN,EACJO,EAAIL,EAAO,EAEf,KAAOI,GAAKJ,GAAUK,GAAKN,GACvBJ,EAAWW,KAAK,CAACF,EAAEC,IACnBV,EAAWW,KAAK,CAACF,EAAEC,IACfZ,EAASW,GAAKX,EAASY,IACvBV,EAAWW,KAAK,CAACH,EAAEV,EAASY,KAC5BR,EAAUM,GAAKV,EAASY,GACxBF,IAAKE,MAELV,EAAWW,KAAK,CAACH,EAAEV,EAASW,KAC5BP,EAAUM,GAAKV,EAASW,GACxBD,IAAIC,KAIZ,KAAOA,GAAIJ,GACPL,EAAWW,KAAK,CAACF,EAAEA,IACnBT,EAAWW,KAAK,CAACF,EAAEA,IACnBT,EAAWW,KAAK,CAACH,EAAEV,EAASW,KAC5BP,EAAUM,GAAKV,EAASW,GACxBD,IAAIC,IAGR,KAAOC,GAAIN,GACPJ,EAAWW,KAAK,CAACD,EAAEA,IACnBV,EAAWW,KAAK,CAACD,EAAEA,IACnBV,EAAWW,KAAK,CAACH,EAAEV,EAASY,KAC5BR,EAAUM,GAAKV,EAASY,GACxBF,IAAIE,IAtCRE,CAAMV,EAAUC,EAASE,EAAOD,EAAON,EAASE,GAXjDC,CAAgBL,EAAM,EAAEA,EAAMC,OAAO,EAAEC,EAASE,GACzCA,ECPH,SAASa,EAAuBjB,GACnC,IAAMI,EAAa,GAEnB,OAKJ,SAASc,EAAUd,EAAWJ,EAAMO,EAASC,GAEzC,GAAID,EAAWC,EAAQ,CACnB,IAAMW,EAMd,SAAmBf,EAAWJ,EAAMO,EAASC,GAIzC,IAFA,IAAMY,EAAQpB,EAAMQ,GAChBK,EAAIN,EAAW,EACVO,EAAIP,EAAUO,GAAKN,EAAO,EAAGM,IAKlC,GAHAV,EAAWW,KAAK,CAACD,EAAEN,IACnBJ,EAAWW,KAAK,CAACD,EAAEN,IAEfR,EAAMc,GAAKM,EAAO,CAClBP,IACAT,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACF,EAAEb,EAAMc,GAAGA,EAAEd,EAAMa,KAEpC,IAAIQ,EAAOrB,EAAMa,GACjBb,EAAMa,GAAKb,EAAMc,GACjBd,EAAMc,GAAKO,EAIfA,EAAOrB,EAAMa,EAAE,GAMnB,OALAT,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACF,EAAE,EAAEb,EAAMQ,GAAQA,EAAOR,EAAMa,EAAE,KAClDb,EAAMa,EAAE,GAAKb,EAAMQ,GACnBR,EAAMQ,GAAUa,EAETR,EAAE,EAhCgBS,CAAUlB,EAAWJ,EAAMO,EAASC,GACzDU,EAAUd,EAAWJ,EAAMO,EAASY,EAAa,GACjDD,EAAUd,EAAWJ,EAAMmB,EAAa,EAAEX,IAX9CU,CAAUd,EAAWJ,EAAM,EAAEA,EAAMC,OAAO,GACnCG,ECmBX,SAASmB,EAAQnB,EAAWJ,EAAMwB,EAAWC,GACzC,IAAIC,EAA8BD,EAC5BE,EAAe,EAAEF,EAAQ,EACzBG,EAAgB,EAAEH,EAAQ,EAkBhC,GAhBIE,EAAeH,IACfpB,EAAWW,KAAK,CAACY,EAAaD,IAC9BtB,EAAWW,KAAK,CAACY,EAAaD,IAC1B1B,EAAM2B,GAAe3B,EAAM0B,KAC3BA,EAA8BC,IAIlCC,EAAgBJ,IAChBpB,EAAWW,KAAK,CAACa,EAAcF,IAC/BtB,EAAWW,KAAK,CAACa,EAAcF,IAC3B1B,EAAM4B,GAAiB5B,EAAM0B,KAC7BA,EAA8BE,IAIlCF,IAAgCD,EAAS,CAEzCrB,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACU,EAAQzB,EAAM0B,GAA6BA,EAA4B1B,EAAMyB,KAE9F,IAAMJ,EAAOrB,EAAMyB,GACnBzB,EAAMyB,GAAWzB,EAAM0B,GACvB1B,EAAM0B,GAA+BL,EAErCE,EAAQnB,EAAWJ,EAAMwB,EAAWE,I,4BCVxCG,GAAY,EAEZC,EAAc,EAIdC,EAAe,EACfC,EAAgB,EAKCC,E,YACjB,WAAYC,GAAQ,IAAD,8BACf,4CAAMA,KAEDC,MAAQ,CACTnC,MAAO,IAJI,E,iFASfoC,KAAKC,oB,wCAKL,IADA,IAAMrC,EAAQ,GACLa,EAAG,EAAGA,EAAGyB,IAAezB,IAC7Bb,EAAMe,KApCK,IAoCAF,GAEfuB,KAAKG,SAAS,CAACvC,Y,mCAKf,IAAI6B,EAAJ,CADS,IAEF7B,EAASoC,KAAKD,MAAdnC,MACPoC,KAAKI,aACLJ,KAAKK,QAAQzC,GACboC,KAAKG,SAAS,CAACvC,a,mCAKf,IADA,IAAM0C,EAAUC,SAASC,uBAAuB,aACvC/B,EAAI,EAAGA,EAAI6B,EAAQzC,OAAQY,IAChC6B,EAAQ7B,GAAGgC,MAAMC,gBAnDP,S,sCAuDFC,GACZ,IAAIlB,EAAJ,CACAA,GAAY,EACZO,KAAKI,aACL,IAAIpC,EAAa,GACb4C,EAAkB,EACtBZ,KAAKa,oBAEa,cAAdF,IACA3C,EAAaL,EAAuBqC,KAAKD,MAAMnC,OAC/CgD,EArFwB,KAwFV,kBAAdD,IACA3C,ECzGL,SAAoCJ,GAGvC,IAFA,IAAMI,EAAa,GAEVS,EAAI,EAAGA,EAAIb,EAAMC,OAAQY,IAAK,CAGnC,IAFA,IAAIqC,EAAUlD,EAAMa,GAChBC,EAAID,EAAE,EACHC,GAAK,GAAKd,EAAMc,GAAKoC,GACxB9C,EAAWW,KAAK,CAACF,EAAEC,IACnBV,EAAWW,KAAK,CAACF,EAAEC,IACnBd,EAAMc,EAAE,GAAKd,EAAMc,GACnBV,EAAWW,KAAK,CAACD,EAAE,EAAEd,EAAMc,KAC3BA,IAEJV,EAAWW,KAAK,CAACF,EAAEC,EAAE,IACrBV,EAAWW,KAAK,CAACF,EAAEC,EAAE,IACrBd,EAAMc,EAAE,GAAKoC,EACb9C,EAAWW,KAAK,CAACD,EAAE,EAAEoC,IAGzB,OAAO9C,EDsFc+C,CAA2Bf,KAAKD,MAAMnC,OACnDgD,EApF2B,GAuF/B,IAlBuB,eAkBdnC,GAEL,IAAM6B,EAAUC,SAASC,uBAAuB,aAEhD,GAAI/B,EAAI,IAAM,EAAG,CAAC,IAAD,cACsBT,EAAWS,GADjC,GACNuC,EADM,KACMC,EADN,KAEPC,EAAWZ,EAAQU,GACnBG,EAAYb,EAAQW,GAC1BG,YAAW,WACPF,EAAST,MAAMC,gBAhFT,QAiFNS,EAAUV,MAAMC,gBAjFV,UAkFPjC,EAAImC,EAAkBjB,QAEtB,GAAIlB,EAAI,IAAM,EAAG,CAAC,IAAD,cACeT,EAAWS,GAD1B,GACbuC,EADa,KACDC,EADC,KAEdC,EAAWZ,EAAQU,GACnBG,EAAYb,EAAQW,GAC1BG,YAAW,WACPF,EAAST,MAAMC,gBA3Fb,OA4FFS,EAAUV,MAAMC,gBA5Fd,SA6FHjC,EAAImC,EAAkBjB,OAEtB,mBAC6B3B,EAAWS,GADxC,GACIuC,EADJ,KACgBK,EADhB,KAEGH,EAAWZ,EAAQU,GACzBI,YAAW,WAEP,GADAF,EAAST,MAAMa,OAAf,UAA2BD,EAA3B,MACI5C,GAAKT,EAAWH,OAAQ,EAAG,CAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAI4B,EAAQzC,OAAQa,IAChC4B,EAAQ5B,GAAG+B,MAAMC,gBAlGb,aAoGRjB,GAAY,KAGjBhB,EAAImC,EAAkBjB,KAlCxBlB,EAAI,EAAGA,EAAIT,EAAWH,OAAQY,IAAM,EAApCA,M,mCAyCAkC,GACT,IAAIlB,EAAJ,CACAA,GAAY,EACZO,KAAKI,aAEL,IAAIpC,EAAa,GACb4C,EAAkB,EACtBZ,KAAKa,oBACa,eAAdF,IACA3C,EE/JL,SAAiCJ,GAKpC,IAHA,IAAMI,EAAa,GACfuD,GAAU,EAEL9C,EAAI,EAAGA,EAAIb,EAAMC,OAAO,EAAGY,IAAK,CACrC,IAAK,IAAIC,EAAI,EAAGA,EAAId,EAAMC,OAAOY,EAAE,EAAGC,IAGlC,GAFAV,EAAWW,KAAK,CAACD,EAAEA,EAAE,IACrBV,EAAWW,KAAK,CAACD,EAAEA,EAAE,IACjBd,EAAMc,GAAKd,EAAMc,EAAE,GAAI,CACvBV,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACD,EAAEd,EAAMc,EAAE,GAAGA,EAAE,EAAEd,EAAMc,KACxC,IAAIO,EAAOrB,EAAMc,GACjBd,EAAMc,GAAKd,EAAMc,EAAE,GACnBd,EAAMc,EAAE,GAAKO,EACbsC,GAAU,EAGlB,IAAKA,EAAS,MAGlB,OAAOvD,EF0IcwD,CAAwBxB,KAAKD,MAAMnC,OAChDgD,EA9IwB,IAiJV,aAAdD,IACA3C,EDpKL,SAA+BJ,GAElC,IADA,IAAMI,EAAa,GACVS,EAAIb,EAAMC,OAAO,EAAG,EAAGY,GAAK,EAAGA,IACpCU,EAAQnB,EAAWJ,EAAMA,EAAMC,OAAOY,GAG1C,IAAK,IAAIA,EAAIb,EAAMC,OAAQ,EAAGY,GAAK,EAAGA,IAAK,CAEvCT,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAAC,EAAEf,EAAMa,GAAGA,EAAEb,EAAM,KAEpC,IAAMqB,EAAOrB,EAAM,GACnBA,EAAM,GAAKA,EAAMa,GACjBb,EAAMa,GAAKQ,EAGXE,EAAQnB,EAAWJ,EAAMa,EAAE,GAG/B,OAAOT,ECiJcyD,CAAsBzB,KAAKD,MAAMnC,OAC9CgD,EA3IsB,GA8IR,cAAdD,IACA3C,EAAaa,EAAuBmB,KAAKD,MAAMnC,OAC/CgD,EAlJuB,KAqJT,kBAAdD,IACA3C,EG9KL,SAAoCJ,GAIvC,IAFA,IAAMI,EAAa,GAEVS,EAAI,EAAGA,EAAIb,EAAMC,OAAQ,EAAGY,IAAK,CAEtC,IADA,IAAIiD,EAAUjD,EACLC,EAAID,EAAE,EAAGC,EAAId,EAAMC,OAAQa,IAChCV,EAAWW,KAAK,CAAC+C,EAAQhD,IACzBV,EAAWW,KAAK,CAAC+C,EAAQhD,IACrBd,EAAMc,GAAKd,EAAM8D,KACjBA,EAAUhD,GAIlBV,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAAC+C,EAAQ9D,EAAMa,GAAGA,EAAEb,EAAM8D,KAC1C,IAAMzC,EAAOrB,EAAMa,GACnBb,EAAMa,GAAKb,EAAM8D,GACjB9D,EAAM8D,GAAWzC,EAGrB,OAAOjB,EHyJc2D,CAA2B3B,KAAKD,MAAMnC,OACnDgD,EA3J2B,IA8Jb,uBAAdD,IACA3C,EInLL,SAAyCJ,GAO5C,IANA,IAAMI,EAAa,GAEfG,EAAW,EACXC,EAASR,EAAMC,OAAQ,EACvB0D,GAAU,EAERA,GAAS,CACXA,GAAU,EAEV,IAAK,IAAI9C,EAAIN,EAAUM,EAAIL,EAAQK,IAG/B,GAFAT,EAAWW,KAAK,CAACF,EAAEA,EAAE,IACrBT,EAAWW,KAAK,CAACF,EAAEA,EAAE,IACjBb,EAAMa,GAAKb,EAAMa,EAAE,GAAI,CACvBT,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACF,EAAEb,EAAMa,EAAE,GAAGA,EAAE,EAAEb,EAAMa,KAExC,IAAIQ,EAAOrB,EAAMa,GACjBb,EAAMa,GAAKb,EAAMa,EAAE,GACnBb,EAAMa,EAAE,GAAKQ,EACbsC,GAAU,EAIlB,IAAKA,EAAS,MACdA,GAAU,EAKV,IAAK,IAAI9C,IAHTL,EAGoB,EAAGK,GAAKN,EAAUM,IAGlC,GAFAT,EAAWW,KAAK,CAACF,EAAEA,EAAE,IACrBT,EAAWW,KAAK,CAACF,EAAEA,EAAE,IACjBb,EAAMa,GAAKb,EAAMa,EAAE,GAAI,CACvBT,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACF,EAAEb,EAAMa,EAAE,GAAGA,EAAE,EAAEb,EAAMa,KAExC,IAAIQ,EAAOrB,EAAMa,GACjBb,EAAMa,GAAKb,EAAMa,EAAE,GACnBb,EAAMa,EAAE,GAAKQ,EACbsC,GAAU,EAKlBpD,IAMJ,OAAOH,EJgIc4D,CAAgC5B,KAAKD,MAAMnC,OACxDgD,EAxJgC,KA2JlB,cAAdD,IACA3C,EKxLL,SAAgCJ,GAGnC,IAFA,IAAMI,EAAa,GAEV6D,EAAMvD,KAAKC,MAAMX,EAAMC,OAAQ,GAAIgE,EAAM,EAAGA,EAAMvD,KAAKC,MAAMsD,EAAI,GAAI,CAC1EC,QAAQC,IAAIF,GAEZ,IAAK,IAAIzD,EAASyD,EAAKzD,EAAOR,EAAMC,OAAQO,IAGxC,IAAK,IAAIM,EAAIN,EAAQM,GAAImD,IAErB7D,EAAWW,KAAK,CAACD,EAAEA,EAAEmD,IACrB7D,EAAWW,KAAK,CAACD,EAAEA,EAAEmD,IAEjBjE,EAAMc,EAAEmD,GAAOjE,EAAMc,IALCA,GAAKmD,EAAK,CAMhC7D,EAAWW,KAAK,QAChBX,EAAWW,KAAK,CAACD,EAAEd,EAAMc,EAAEmD,GAAKnD,EAAEmD,EAAIjE,EAAMc,KAC5C,IAAIO,EAAOrB,EAAMc,GACjBd,EAAMc,GAAKd,EAAMc,EAAEmD,GACnBjE,EAAMc,EAAEmD,GAAO5C,GAQ/B,OAAOjB,EL6JcgE,CAAuBhC,KAAKD,MAAMnC,OAC/CgD,EA3JuB,KA8J3B,IAtCoB,kBAwChB,IAAMN,EAAUC,SAASC,uBAAuB,aAEhD,GAAI/B,EAAI,IAAM,EACV,GAAsB,SAAlBT,EAAWS,GAAe,mBAEKT,EAAWS,GAFhB,GAEvBuC,EAFuB,KAEXC,EAFW,KAGxBC,EAAWZ,EAAQU,GACnBG,EAAYb,EAAQW,GAC1BG,YAAW,WACPF,EAAST,MAAMC,gBAjKT,QAkKNS,EAAUV,MAAMC,gBAlKV,UAmKHjC,EAAImC,EAAkBjB,OACtB,CACHlB,IADG,kBAEsDT,EAAWS,GAFjE,GAEIuC,EAFJ,KAEgBiB,EAFhB,KAE2BhB,EAF3B,KAEwCiB,EAFxC,KAGGhB,EAAWZ,EAAQU,GACnBG,EAAYb,EAAQW,GAC1BG,YAAW,WAGP,GAFAF,EAAST,MAAMa,OAAf,UAA2BW,EAA3B,MACAd,EAAUV,MAAMa,OAAhB,UAA4BY,EAA5B,MACIzD,GAAKT,EAAWH,OAAQ,EAAG,CAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAI4B,EAAQzC,OAAQa,IAChC4B,EAAQ5B,GAAG+B,MAAMC,gBA5KjB,aA8KJjB,GAAY,KAIjBhB,EAAImC,EAAkBjB,OAI1B,mBACgC3B,EAAWS,GAD3C,GACIuC,EADJ,KACgBC,EADhB,KAEGC,EAAWZ,EAAQU,GACnBG,EAAYb,EAAQW,GAC1BG,YAAW,WAIP,GAHAF,EAAST,MAAMC,gBA/Lb,OAgMFS,EAAUV,MAAMC,gBAhMd,OAkMEjC,GAAKT,EAAWH,OAAQ,EAAG,CAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAI4B,EAAQzC,OAAQa,IAChC4B,EAAQ5B,GAAG+B,MAAMC,gBAhMb,aAkMRjB,GAAY,KAIjBhB,EAAImC,EAAkBjB,GAxFb,KAsCXlB,EAAI,EAAGA,EAAIT,EAAWH,OAAQY,IAAM,EAApCA,M,0CA4DX,IAAI0D,EAAS5B,SAAS6B,eAAe,WACrCzC,EAAe,EAAEwC,EAAOE,Q,mCAItBrC,KAAKsC,aAAa,gB,iCAIlBtC,KAAKsC,aAAa,c,kCAIlBtC,KAAKsC,aAAa,e,sCAIlBtC,KAAKsC,aAAa,mB,2CAIlBtC,KAAKsC,aAAa,wB,kCAIlBtC,KAAKuC,gBAAgB,e,sCAIrBvC,KAAKuC,gBAAgB,mB,kCAKrBvC,KAAKsC,aAAa,e,oCAKlBE,OAAOC,SAASC,W,qCAUhB,IAAIC,EAAQpC,SAAS6B,eAAe,YACpCO,EAAMlC,MAAMmC,QAAU,QAGtB,IAAIC,EAAMtC,SAAS6B,eAAe,eAG9BU,EAAOvC,SAASC,uBAAuB,SAAS,GAEpDsB,QAAQC,IAAIY,EAAOE,EAAKC,GAGxBA,EAAKC,QAAU,WACbJ,EAAMlC,MAAMmC,QAAU,QAIxBJ,OAAOO,QAAU,SAAUC,GACrBA,EAAMC,QAAUN,IAClBA,EAAMlC,MAAMmC,QAAU,SAG1B5C,KAAKkD,WAAW,K,mCAILC,GACX,IAAIR,EAAQpC,SAAS6B,eAAe,cACpCO,EAAMlC,MAAMmC,QAAU,QAMXrC,SAASC,uBAAuB,cAAc,GAKpDuC,QAAU,WACbJ,EAAMlC,MAAMmC,QAAU,QAIxBJ,OAAOO,QAAU,SAAUC,GACrBA,EAAMC,QAAUN,IAClBA,EAAMlC,MAAMmC,QAAU,SAG1BrC,SAAS6B,eACP,sBACAgB,UM5VH,SAA8BD,GACjC,OAAQA,GACN,KAAK,EACH,MAAM,8vDAoCR,KAAK,EACH,MAAM,+nCA8BR,KAAK,EACH,MAAM,07CAgCR,KAAK,EACH,MAAM,+/CA+BR,KAAK,EACH,MAAM,0/EA0CR,KAAK,EACH,MAAM,ysFA0CR,KAAK,EACH,MAAM,qqDA8BR,KAAK,EACH,MAAM,kjEAuCR,QACE,MAAM,6DNuDQE,CAAqBF,K,iCAG9BG,GAiBT,OAbY,GAARA,EAHa,IAIX5D,EACFA,EALa,EAObA,GAAe4D,EANF,IASX5D,EACFA,EAVa,EAYbA,GAAe4D,EAGX5D,GACN,KAAK,EACHa,SAAS6B,eAAe,oBAAoBgB,UAC1CpD,KAAKuD,WAnBM,GAmBX,+yCAYF,MAGF,KAAK,EACHhD,SAAS6B,eAAe,oBAAoBgB,UAC1CpD,KAAKuD,WApCM,GAoCX,yyBAOF,MAGF,KAAK,EACHhD,SAAS6B,eAAe,oBAAoBgB,UAC1CpD,KAAKuD,WAhDM,GAgDX,06CAeF,MAGF,KAAK,EACHhD,SAAS6B,eAAe,oBAAoBgB,UAC1CpD,KAAKuD,WApEM,GAoEX,kwDAYF,MAGF,KAAK,EACHhD,SAAS6B,eAAe,oBAAoBgB,UAC1CpD,KAAKuD,WArFM,GAqFX,mjDA2BN,IAAIC,EAAUjD,SAAS6B,eAAe,QAClCqB,EAAUlD,SAAS6B,eAAe,QAhHrB,IAiHb1C,GACF8D,EAAQ/C,MAAMC,gBAAkB,YAChC8C,EAAQE,UAAW,GApHJ,IAqHNhE,GACT+D,EAAQC,UAAW,EACnBD,EAAQhD,MAAMC,gBAAkB,cAEhCoB,QAAQC,IAAI,gBACZyB,EAAQE,UAAW,EACnBF,EAAQ/C,MAAMC,gBAAkB,sBAChC+C,EAAQC,UAAW,EACnBD,EAAQhD,MAAMC,gBAAkB,yB,iCAKzBiD,GACT,MACE,OACAjE,EADA,IAGAiE,EAHA,Y,qCAWF,IAAIxB,EAAS5B,SAAS6B,eAAe,WACjCwB,EAAcrD,SAAS6B,eAAe,eACvC3C,IACD0C,EAAOE,MAAQzC,GAEjBuC,EAAOE,MAAQF,EAAOE,MACtBzC,EAAgBuC,EAAOE,MAGvBuB,EAAYR,UAAY,UAAUjB,EAAOE,MAAjB,IACxBP,QAAQC,IAAII,EAAOE,S,+BAKT,IAAD,OACCzE,EAASoC,KAAKD,MAAdnC,MAEN,OACA,oCACA,yBAAKiG,UAAU,mBACf,yBAAKA,UAAU,QAAQC,QAAS,kBAAM,EAAKC,gBAA3C,iCAIA,yBAAKF,UAAU,oBAEb,4BACEG,GAAG,cACHH,UAAU,cACVC,QAAS,kBAAM,EAAKG,iBAEnB,IALH,IAMI,KAGJ,4BAAQH,QAAS,kBAAM,EAAKI,eAA5B,gBAGF,yBAAKL,UAAY,mBACf,2BAAOM,KAAK,QAAQC,IAped,GAoe8BC,IAre9B,GAqe8CC,KAne9C,IAme+DC,aAAgB3E,EAAeiE,UAAY,SAASG,GAAG,UAAUQ,SAAY,kBAAI,EAAKC,mBAEjK,0BAAMT,GAAG,cAAcH,UAAY,eAAnC,WAA0DjE,EAA1D,MAGI,yBAAKoE,GAAG,WAAWH,UAAU,SAC3B,yBAAKA,UAAU,mBACb,0BAAMG,GAAG,QAAQH,UAAU,SAA3B,QAGA,yBAAKA,UAAU,qBACb,yBAAKA,UAAU,gBACb,4BAAQG,GAAG,OAAOF,QAAS,kBAAM,EAAKZ,YAAY,KAC/C,IADH,OAEO,KAEP,4BAAQc,GAAG,OAAOF,QAAS,kBAAM,EAAKZ,WAAW,KAC9C,IADH,OAEO,QAKb,yBAAKc,GAAG,mBAAmBH,UAAU,mBAGvC,yBAAKG,GAAG,aAAaH,UAAU,cAC7B,0BAAMG,GAAG,aAAaH,UAAU,cAAhC,QAGA,yBAAKG,GAAG,qBAAqBH,UAAU,wBAGzC,yBAAKA,UAAU,aACb,yBAAKA,UAAU,kBACb,4BAAQC,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,YACA,4BAAQZ,QAAS,kBAAM,EAAKY,aAAa,KAAzC,aAGA,yBAAKb,UAAY,aACjB,4BAAQC,QAAW,kBAAM,EAAKa,eAA9B,gBACA,4BAAQb,QAAW,kBAAM,EAAKc,kBAA9B,mBACA,4BAAQd,QAAW,kBAAM,EAAKe,kBAA9B,mBACA,4BAAQf,QAAW,kBAAM,EAAKgB,cAA9B,eACA,4BAAQhB,QAAW,kBAAM,EAAKiB,aAA9B,cACA,4BAAQjB,QAAW,kBAAM,EAAKhF,cAA9B,eACA,4BAAQgF,QAAW,kBAAM,EAAKkB,uBAA9B,yBACA,4BAAQlB,QAAW,kBAAM,EAAKmB,cAA9B,gBAIA,yBAAKpB,UAAU,mBACdjG,EAAMsH,KAAI,SAAC7C,EAAM8C,GAAP,OACP,yBAAKtB,UAAY,YAAYuB,IAAOD,EAAK1E,MAAS,CAACa,OAAO,GAAD,OAAKe,EAAL,iB,mCAgB3D+B,EAAIC,GAGV,OAFAD,EAAM9F,KAAK+G,KAAKjB,GAChBC,EAAM/F,KAAKC,MAAM8F,GACV/F,KAAKC,MAAMD,KAAKgH,UAAYjB,EAAMD,EAAM,IAAMA,I,8BAIjDxG,GACJ,IAAK,IAAIa,EAAIb,EAAMC,OAAS,EAAGY,EAAI,EAAGA,IAAK,CACzC,IAAIC,EAAIJ,KAAKC,MAAMD,KAAKgH,UAAY7G,EAAI,IADC,EAElB,CAACb,EAAMc,GAAId,EAAMa,IAAvCb,EAAMa,GAFkC,KAE9Bb,EAAMc,GAFwB,U,GApjBJ6G,IAAMC,W,MOzCtCC,MATf,WAEE,OADAlF,SAASmF,MAAQ,UAEf,yBAAK7B,UAAU,OACb,kBAAC,EAAD,QCIc8B,QACW,cAA7BnD,OAAOC,SAASmD,UAEe,UAA7BpD,OAAOC,SAASmD,UAEhBpD,OAAOC,SAASmD,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASxF,SAAS6B,eAAe,SD6H3C,kBAAmB4D,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.9812c8a6.chunk.js","sourcesContent":["export function getMergeSortAnimations(array) {\n\n    if (array.length <= 1) return array;\n    const auxArray = array.slice();\n    const animations = [];\n\n   mergeSortHelper(array,0,array.length-1,auxArray,animations);\n   return animations;\n\n\n}\n\nfunction mergeSortHelper(mainArray,startIdx,endIdx,auxArray,animations) {\n    if (startIdx === endIdx) return;\n    const midIdx = Math.floor((startIdx + endIdx)/2);\n    mergeSortHelper(auxArray,startIdx,midIdx,mainArray,animations); //why is order aux then main?\n    mergeSortHelper(auxArray,midIdx+1,endIdx,mainArray,animations);\n    merge(mainArray,startIdx,midIdx,endIdx,auxArray,animations);\n}\n\n\n\n\nfunction merge(mainArray,startIdx,midIdx,endIdx,auxArray,animations) {\n    var k = startIdx;  //index for mainArray\n    var i = startIdx;  //index for first half of auxArray\n    var j = midIdx+1;  //index for second half of auxArray\n\n    while (i <= midIdx && j <= endIdx) {\n        animations.push([i,j]);\n        animations.push([i,j]);\n        if (auxArray[i] > auxArray[j]) {\n            animations.push([k,auxArray[j]]);\n            mainArray[k] = auxArray[j];\n            k++; j++;\n        } else {\n            animations.push([k,auxArray[i]]);\n            mainArray[k] = auxArray[i];\n            k++;i++;\n        }\n    }\n\n    while (i<= midIdx) {\n        animations.push([i,i]);\n        animations.push([i,i]);\n        animations.push([k,auxArray[i]]);\n        mainArray[k] = auxArray[i];\n        k++;i++;\n    }\n\n    while (j<= endIdx) {\n        animations.push([j,j]);\n        animations.push([j,j]);\n        animations.push([k,auxArray[j]]);\n        mainArray[k] = auxArray[j];\n        k++;j++;\n    }\n} \n/*\nmergeSort\n\n\nfunction mergeSort(array,startIdx,endIdx) {\n    // base case of recursion, return the single element array\n    if (startIdx === endIdx) return array;\n\n    // calculate index of middle element\n    const midIdx = Math.floor((startIdx + endIdx)/2);\n    // recursive call to sort first half of array\n    const firstHalfSorted = mergeSort(array,startIdx,midIdx);\n    // recursive call to sort second half of array\n    const secondHalfSorted = mergeSort(array,midIdx+1,endIdx);\n    // merge the two sorted halves to a final sorted array, and return\n    return merge(firstHalfSorted,secondHalfSorted);\n}\n\n\n// given two individually sorted arrays, combine into a single sorted array\nfunction merge(firstArray,secondArray) {\n    let mergedArray = [];\n    // enter while loop when either of the two arrays have elements remaining\n    // exit while loop when at least one array is empty (arrays may not be same size)\n    while (firstArray.length !== 0 && secondArray.length !== 0) {\n        // compare first element of each array\n        if (firstArray[0] > secondArray[0]) {\n            // since both arrays are sorted, secondArray[0] is the smallest element\n            // so we know this should go at the front of the merged array\n            mergedArray.push(secondArray[0]);\n            // remove secondArray[0] from front of array, and loop back\n            secondArray.shift();\n        } else {\n            // since both arrays are sorted, firstArray[0] is the smallest element\n            // so we know this should go at the front of the merged array\n            mergedArray.push(firstArray[0]);\n            // remove firstArray[0] from front of array, and loop back\n            firstArray.shift();\n        }\n    }\n    // if firstArray and secondArray were different sizes, we just push the remaining\n    // elements into the back of the mergedArray. This works since both are sorted, so\n    // WLOG if firstArray still has elements, all of these will be greater than the elements\n    // in mergedArray. Thus, we can push into mergedArray, and mergedArray will be sorted \n    while (firstArray.length !== 0) {\n        mergedArray.push(firstArray[0]);\n        firstArray.shift();\n    }\n    while (secondArray.length !== 0) {\n        mergedArray.push(secondArray[0]);\n        secondArray.shift();\n    }\n    // mergedArray contains all elements of firstArray and secondArray, and is sorted.\n    return mergedArray;\n}\n\n*/","export function getQuickSortAnimations(array) {\n    const animations = [];\n    quickSort(animations,array,0,array.length-1);\n    return animations;\n    \n}\n\n\nfunction quickSort(animations,array,startIdx,endIdx) {\n\n    if (startIdx < endIdx) {\n        const partitionIdx = partition(animations,array,startIdx,endIdx);\n        quickSort(animations,array,startIdx,partitionIdx-1);\n        quickSort(animations,array,partitionIdx+1,endIdx);\n    }\n}\n\nfunction partition(animations,array,startIdx,endIdx) {\n    //picks last element as pivot\n    const pivot = array[endIdx];\n    let i = startIdx - 1;\n    for (let j = startIdx; j <= endIdx-1; j++) {\n\n        animations.push([j,endIdx]);\n        animations.push([j,endIdx]);\n        \n        if (array[j] < pivot) {\n            i++;\n            animations.push(\"Swap\");\n            animations.push([i,array[j],j,array[i]]);\n            //swap array[i] and array[j]\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n    }\n    //swap array[i+1] and array[endIdx]\n    var temp = array[i+1];\n    animations.push(\"Swap\");\n    animations.push([i+1,array[endIdx],endIdx,array[i+1]]);\n    array[i+1] = array[endIdx];\n    array[endIdx] = temp;\n    \n    return i+1;\n\n}\n\n/*\n\nfunction quickSort(array,startIdx,endIdx) {\n    // if startIdx >= endIdx, do nothing\n    if (startIdx < endIdx) {\n        // partition the array, and get the partition index\n        const partitionIdx = partition(array,startIdx,endIdx);\n        // quickSort the sub array to the left of partition\n        quickSort(array,startIdx,partitionIdx-1);\n        // quickSort the sub array to the right of partition\n        quickSort(array,partitionIdx+1,endIdx);\n    }\n}\n\n\nfunction partition(array,startIdx,endIdx) {\n    // picks last element as the partition value (pivot)\n    const pivot = array[endIdx];\n    // i is index of elements smaller than pivot\n    let i = startIdx - 1;\n    // iterate over array from start index to end index - 1\n    for (let j = startIdx; j <= endIdx-1; j++) {\n        // compares and puts all elements less than pivot, to the left of pivot\n        if (array[j] < pivot) {\n            // move over index of element smaller than pivot \n            i++;\n            // swap array[i] and array[j]\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n    }\n    // now, by default, all values greater than pivot are to the right of index i+1\n\n    // swap array[i+1] (where pivot belongs) and array[endIdx] (pivot)\n    // notice: array[i+1] > pivot. Why?\n    var temp = array[i+1];\n    array[i+1] = array[endIdx];\n    array[endIdx] = temp;\n    // i+1 is index where partition was inserted\n    return i+1;\n\n}\n\n*/","export function getHeapSortAnimations(array) {\n    const animations = [];\n    for (let i = array.length/2 -1; i >= 0; i--) {\n        heapify(animations,array,array.length,i);\n    }\n\n    for (let i = array.length -1; i >= 0; i--) {\n\n        animations.push(\"Swap\");\n        animations.push([0,array[i],i,array[0]]);\n        //swap current index i (smallest element) to the beginning (index 0)\n        const temp = array[0];\n        array[0] = array[i];\n        array[i] = temp;\n\n        //heapify on reduced heap\n        heapify(animations,array,i,0)\n    }\n\n    return animations;\n}\n\nfunction heapify(animations,array,sizeOfHeap,rootIdx) {\n    var largestOfRootAndChildrenIdx = rootIdx;\n    const leftChildIdx = 2*rootIdx+1;\n    const rightChildIdx = 2*rootIdx+2;\n\n    if (leftChildIdx < sizeOfHeap) {\n        animations.push([leftChildIdx,largestOfRootAndChildrenIdx]);\n        animations.push([leftChildIdx,largestOfRootAndChildrenIdx]);\n        if (array[leftChildIdx]> array[largestOfRootAndChildrenIdx]) {\n            largestOfRootAndChildrenIdx = leftChildIdx;\n        }\n    }\n\n    if (rightChildIdx < sizeOfHeap) {\n        animations.push([rightChildIdx,largestOfRootAndChildrenIdx]);\n        animations.push([rightChildIdx,largestOfRootAndChildrenIdx]);\n        if (array[rightChildIdx] > array[largestOfRootAndChildrenIdx]) {\n            largestOfRootAndChildrenIdx = rightChildIdx;\n        }\n    }\n\n    if (largestOfRootAndChildrenIdx !== rootIdx) {\n        //swap array[rootIdx] and array[largestOfRootAndChildrenIdx]\n        animations.push(\"Swap\");\n        animations.push([rootIdx,array[largestOfRootAndChildrenIdx],largestOfRootAndChildrenIdx,array[rootIdx]]);\n\n        const temp = array[rootIdx];\n        array[rootIdx] = array[largestOfRootAndChildrenIdx];\n        array[largestOfRootAndChildrenIdx] = temp;\n        \n        heapify(animations,array,sizeOfHeap,largestOfRootAndChildrenIdx);\n    }\n\n\n} \n/*\nheapSort\n\n\nfunction heapSort(array) {\n    // Total O(n) time to buildHeap\n    for (let i = array.length/2 -1; i >= 0; i--) {\n        heapify(animations,array,array.length,i);\n    }\n    // iterate over heap\n    for (let i = array.length -1; i >= 0; i--) {\n        //swap max value (array[0]) to end of array at index i\n        const temp = array[0];\n        array[0] = array[i];\n        array[i] = temp;\n        //heapify on reduced heap, to ensure next iteration works\n        heapify(animations,array,i,0)\n    }\n}\n\n\nfunction heapify(animations,array,sizeOfHeap,rootIdx) {\n    var largestOfRootAndChildrenIdx = rootIdx;\n    const leftChildIdx = 2*rootIdx+1;\n    const rightChildIdx = 2*rootIdx+2;\n    // if leftChildIdx is within array, and its value is larger than value at largestOfRootAndChildrenIdx, update\n    if (leftChildIdx < sizeOfHeap && array[leftChildIdx]> array[largestOfRootAndChildrenIdx]) {\n        largestOfRootAndChildrenIdx = leftChildIdx;\n    }\n    // if rightChildIdx is within array, and its value is larger than value at largestOfRootAndChildrenIdx, update\n    if (rightChildIdx < sizeOfHeap && array[rightChildIdx] > array[largestOfRootAndChildrenIdx]) {\n        largestOfRootAndChildrenIdx = rightChildIdx;\n    }\n    // if at least one of the previous 2 \"if\" statements were true\n    if (largestOfRootAndChildrenIdx !== rootIdx) {\n        //swap array[rootIdx] and array[largestOfRootAndChildrenIdx]\n        const temp = array[rootIdx];\n        array[rootIdx] = array[largestOfRootAndChildrenIdx];\n        array[largestOfRootAndChildrenIdx] = temp;\n        // recursive call on largest child as root\n        heapify(animations,array,sizeOfHeap,largestOfRootAndChildrenIdx);\n    }\n}\n*/","import React from 'react';\nimport './SortingVisualizer.css';\nimport {getMergeSortAnimations} from '../SortingAlgorithms/mergeSort';\nimport {getBubbleSortAnimations} from '../SortingAlgorithms/bubbleSort';\nimport {getSelectionSortAnimations} from '../SortingAlgorithms/selectionSort';\nimport {getInsertionSortAnimations} from '../SortingAlgorithms/insertionSort';\nimport {getQuickSortAnimations} from '../SortingAlgorithms/quickSort';\nimport {getHeapSortAnimations} from '../SortingAlgorithms/heapSort';\nimport {getCocktailShakerSortAnimations} from '../SortingAlgorithms/cocktailShaker';\nimport {getShellSortAnimations} from '../SortingAlgorithms/shellSort';\nimport {displayAlgorithmInfo} from '../SortingAlgorithms/AlgorithmInfo';\nimport \"../Components/Button.css\";\nimport \"../Components/Modal.css\";\nimport \"../Components/AlgorithmModal.css\";\nimport \"../Components/Slider.css\";\n\nconst ANIMATION_SPEED_MERGE_SORT  = 3.6; //smaller the speed value, the faster the sort\n\nconst ANIMATION_SPEED_BUBBLE_SORT = 0.6;\n\nconst ANIMATION_SPEED_SELECTION_SORT = 0.7;\n\nconst ANIMATION_SPEED_INSERTION_SORT = 1;\n\nconst ANIMATION_SPEED_QUICK_SORT = 2.7;\n\nconst ANIMATION_SPEED_HEAP_SORT = 2;\n\nconst ANIMATION_SPEED_COCKTAILSHAKER_SORT = 0.55;\n\nconst ANIMATION_SPEED_SHELL_SORT = 2.3;\n\nvar NUM_OF_BARS = 100;\n\nconst SCALING_FACTOR = 5.4;\n\nconst NORMAL_COLOUR = 'cyan';\n\nconst COMPARISON_COLOUR = 'black'; //black???\n\nconst FINISHED_SORTING_COLOUR = 'chartreuse'\n\nvar isRunning = false;\n\nvar slideNumber = 0;\n\n//\n\nvar SPEED_FACTOR = 0;\nvar DEFAULT_VALUE = 1;\nvar MAX_VALUE = 10;\nvar MIN_VALUE = 0.1;\nvar STEP_SIZE = 0.01;\n\nexport default class SortingVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            array: [],\n        };\n    }\n\n    componentDidMount() {\n        this.initializeArray();\n    }\n\n    initializeArray() {\n        const array = []; \n        for (let i =1; i< NUM_OF_BARS+1; i++) {\n            array.push(i*SCALING_FACTOR);\n        }\n        this.setState({array});\n\n    }\n\n    resetArray() {\n        if (isRunning) return;\n        const {array} = this.state;\n        this.resetColor();\n        this.shuffle(array);\n        this.setState({array});\n    }\n\n    resetColor() {\n        const allBars = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < allBars.length; i++) {\n            allBars[i].style.backgroundColor = NORMAL_COLOUR;\n        }\n    }\n\n    sortWithOutSwap(algorithm) { //Sorting Algorithms that DO NOT SWAP... hence use mod 3\n        if (isRunning) return;\n        isRunning = true;\n        this.resetColor();\n        let animations = [];\n        let ANIMATION_SPEED = 0;\n        this.changeSpeedFactor();\n\n        if (algorithm === \"mergeSort\") {\n            animations = getMergeSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_MERGE_SORT;\n        }\n\n        if (algorithm === \"insertionSort\") {\n            animations = getInsertionSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_INSERTION_SORT;\n        }\n\n        for (let i = 0; i < animations.length; i++) {           //using var i = 0 doesnt work for some reason...\n\n            const allBars = document.getElementsByClassName('array-bar');\n\n            if (i % 3 === 0) {\n                const [firstBarIdx,secondBarIdx] = animations[i];\n                const firstBar = allBars[firstBarIdx];\n                const secondBar = allBars[secondBarIdx];\n                setTimeout(() => {\n                    firstBar.style.backgroundColor = COMPARISON_COLOUR;\n                    secondBar.style.backgroundColor = COMPARISON_COLOUR;\n                }, i * ANIMATION_SPEED * SPEED_FACTOR);\n\n            } else if (i % 3 === 1) {\n                const [firstBarIdx,secondBarIdx] = animations[i];\n                const firstBar = allBars[firstBarIdx];\n                const secondBar = allBars[secondBarIdx];\n                setTimeout(() => {\n                    firstBar.style.backgroundColor = NORMAL_COLOUR;\n                    secondBar.style.backgroundColor = NORMAL_COLOUR;\n                }, i * ANIMATION_SPEED * SPEED_FACTOR);\n\n            } else { //i % 3 === 2\n                const [firstBarIdx,newHeight] = animations[i];\n                const firstBar = allBars[firstBarIdx];\n                setTimeout(() => {\n                    firstBar.style.height = `${newHeight}px`;\n                    if (i == animations.length -1) {\n                        for (let j = 0; j < allBars.length; j++) {\n                            allBars[j].style.backgroundColor = FINISHED_SORTING_COLOUR;\n                        }\n                        isRunning = false;\n    //                console.log(isRunning);\n                    }\n                }, i * ANIMATION_SPEED * SPEED_FACTOR);\n            }\n\n        }\n\n    }\n\n    sortWithSwap(algorithm) { //Sorting Algorithms that SWAP... hence use mod 2\n        if (isRunning) return;\n        isRunning = true;\n        this.resetColor();\n\n        let animations = [];\n        let ANIMATION_SPEED = 0;\n        this.changeSpeedFactor();\n        if (algorithm === \"bubbleSort\") {\n            animations = getBubbleSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_BUBBLE_SORT;\n        }\n\n        if (algorithm === \"heapSort\") {\n            animations = getHeapSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_HEAP_SORT;\n        }\n\n        if (algorithm === \"quickSort\") {\n            animations = getQuickSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_QUICK_SORT;\n        }\n\n        if (algorithm === \"selectionSort\") {\n            animations = getSelectionSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_SELECTION_SORT;\n        }\n\n        if (algorithm === \"cocktailShakerSort\") {\n            animations = getCocktailShakerSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_COCKTAILSHAKER_SORT;\n        }\n\n        if (algorithm === \"shellSort\") {\n            animations = getShellSortAnimations(this.state.array);\n            ANIMATION_SPEED = ANIMATION_SPEED_SHELL_SORT;\n        }\n\n        for (let i = 0; i < animations.length; i++) {           //using var i = 0 doesnt work for some reason...\n\n            const allBars = document.getElementsByClassName('array-bar');\n\n            if (i % 2 === 0) {\n                if (animations[i] !== \"Swap\") {\n//                    console.log(i);\n                const [firstBarIdx,secondBarIdx] = animations[i];\n                const firstBar = allBars[firstBarIdx];\n                const secondBar = allBars[secondBarIdx];\n                setTimeout(() => {\n                    firstBar.style.backgroundColor = COMPARISON_COLOUR;\n                    secondBar.style.backgroundColor = COMPARISON_COLOUR;\n                    }, i * ANIMATION_SPEED * SPEED_FACTOR);\n                } else {\n                    i++;\n                    const [firstBarIdx,newHeight1,secondBarIdx,newHeight2] = animations[i];\n                    const firstBar = allBars[firstBarIdx];\n                    const secondBar = allBars[secondBarIdx];\n                    setTimeout(() => {\n                        firstBar.style.height = `${newHeight1}px`;\n                        secondBar.style.height = `${newHeight2}px`;\n                        if (i == animations.length -1) {\n                            for (let j = 0; j < allBars.length; j++) {\n                                allBars[j].style.backgroundColor = FINISHED_SORTING_COLOUR;\n                            }\n                            isRunning = false;\n                        }\n    //                    console.log(isRunning);\n\n                    }, i * ANIMATION_SPEED * SPEED_FACTOR);\n\n            }\n\n            } else { // i % 2 === 1\n                const [firstBarIdx,secondBarIdx] = animations[i];\n                const firstBar = allBars[firstBarIdx];\n                const secondBar = allBars[secondBarIdx];\n                setTimeout(() => {\n                    firstBar.style.backgroundColor = NORMAL_COLOUR;\n                    secondBar.style.backgroundColor = NORMAL_COLOUR;\n\n                    if (i == animations.length -1) {\n                        for (let j = 0; j < allBars.length; j++) {\n                            allBars[j].style.backgroundColor = FINISHED_SORTING_COLOUR;\n                        }\n                        isRunning = false;\n                    }\n    //               console.log(isRunning);\n\n                }, i * ANIMATION_SPEED * SPEED_FACTOR);\n\n\n        }\n\n\n        }\n    }\n\n    changeSpeedFactor(){\n      var slider = document.getElementById(\"myRange\");\n      SPEED_FACTOR = 1/slider.value;\n    }\n\n    bubbleSort() { \n        this.sortWithSwap(\"bubbleSort\");\n    }\n\n    heapSort() {\n        this.sortWithSwap(\"heapSort\");\n    }\n\n    quickSort() {\n        this.sortWithSwap(\"quickSort\");\n    }\n\n    selectionSort() {\n        this.sortWithSwap(\"selectionSort\");\n    }\n\n    cocktailShakerSort() {\n        this.sortWithSwap(\"cocktailShakerSort\");\n    }\n\n    mergeSort() {\n        this.sortWithOutSwap(\"mergeSort\");\n    }\n\n    insertionSort() {\n        this.sortWithOutSwap(\"insertionSort\");\n    }\n\n\n    shellSort() {\n        this.sortWithSwap(\"shellSort\");\n\n    }\n\n    refreshPage() {\n        window.location.reload();\n      }\n\n\n      openHelpMenu() {\n        //make new jsx and css page for the helper menu\n        // make sure background is not interactable when help menu is open\n        // add X button to close\n        // describe algorithms, link github repo site, add tutorial how to work, add motivation why we made the application\n        // Get the modal\n        var modal = document.getElementById(\"helpMenu\");\n        modal.style.display = \"block\";\n    \n        // Get the button that opens the modal\n        var btn = document.getElementById(\"info-button\");\n    \n        // Get the <span> element that closes the modal\n        var span = document.getElementsByClassName(\"close\")[0];\n    \n        console.log(modal, btn, span);\n    \n        // When the user clicks on <span> (x), close the modal\n        span.onclick = function () {\n          modal.style.display = \"none\";\n        };\n    \n        // When the user clicks anywhere outside of the modal, close it\n        window.onclick = function (event) {\n          if (event.target == modal) {\n            modal.style.display = \"none\";\n          }\n        };\n        this.changeText(1);\n      }\n\n\n      openAlgoMenu(info) {\n        var modal = document.getElementById(\"algo-modal\");\n        modal.style.display = \"block\";\n    \n        // // Get the button that opens the modal\n        // var btn = document.getElementById(\"info-button\");\n    \n        // Get the <span> element that closes the modal\n        var span = document.getElementsByClassName(\"algo-close\")[0];\n    \n        //console.log(modal, btn, span);\n    \n        // When the user clicks on <span> (x), close the modal\n        span.onclick = function () {\n          modal.style.display = \"none\";\n        };\n    \n        // When the user clicks anywhere outside of the modal, close it\n        window.onclick = function (event) {\n          if (event.target == modal) {\n            modal.style.display = \"none\";\n          }\n        };\n        document.getElementById(\n          \"algo-modal-content\"\n        ).innerHTML = displayAlgorithmInfo(info);\n      }\n\n  changeText(next) {\n    const MAXSLIDE = 5;\n    const MINSLIDE = 1;\n\n    if (next == 1) {\n      if (slideNumber === MAXSLIDE) {\n        slideNumber = MAXSLIDE;\n      } else {\n        slideNumber += next;\n      }\n    } else {\n      if (slideNumber === MINSLIDE) {\n        slideNumber = MINSLIDE;\n      } else {\n        slideNumber += next;\n      }\n    }\n    switch (slideNumber) {\n      case 1: {\n        document.getElementById(\"helpMenu-content\").innerHTML =\n          this.HTMLHelper(MAXSLIDE) +\n          `\n        <h2 style= \"margin-top: -0.3em;\"> Welcome to our Sorting Algorithms Visualizer </h2> \n        <h3 style= \"margin-top: -0.7em;\"> Made by Eric K. and Ryan L.</h3>\n        <p> This application allows you to visualize 8 common sorting algorithms in action, while learning about their runtime and how they work! Sorting algorithms play an important role\n        in the world today, often being used to simplify other problems, and improve the complexity of solutions. Being able to understand the trade-offs between different sorting \n        algorithms, and being able to recognize which algorithm is optimal for a particular situation can drastically improve performance. Whether you are learning\n        about sorting algorithms for the first time, or are reviewing the material in preparation for an exam or interview, we hope you find this application useful \n        in your studies as a computer scientist!  \n           </p>\n        <p> Click on <strong>Next</strong> to continue the tutorial. Otherwise click anywhere outside the box, or the <strong>X</strong> button to play around with our application</p>\n        <p><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;\" src=\"https://i.imgur.com/0pmWEyQ.png\" alt=\"\" width=\"175\" height=\"185\" /></p>`;\n        break;\n      }\n\n      case 2: {\n        document.getElementById(\"helpMenu-content\").innerHTML =\n          this.HTMLHelper(MAXSLIDE) +\n          `<h2 style= \"margin-top: -0.3em;\">Motivation</h2>\n        <p> We wanted to make this application because when first learning about sorting algorithms, we found it was difficult to imagine the algorithms running in our heads just looking\n        at the code. And so, we created this application where you can not only learn about common sorting algorithms, but also visualize them in a centralized platform. We hope that this\n        application will help you learn why and how these sorting algorithms work in a concise and visual manner, while having fun along the way!\n        </p>\n        <p><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;\" src=\"https://image.flaticon.com/icons/png/512/584/584641.png\" alt=\"\" width=\"129\" height=\"129\" /></p>`;\n        break;\n      }\n\n      case 3: {\n        document.getElementById(\"helpMenu-content\").innerHTML =\n          this.HTMLHelper(MAXSLIDE) +\n          `<h2 style= \"margin-top: -0.3em;\"> How to Use </h2>\n        <p style = \"line-height: 1.15em;\"> Click the \"Scramble!\" button at the top bar to randomly shuffle the bars. When you are ready, click the sorting algorithm button\n        of choice on the left side of your screen. During the animations, the black bars represent the bars being compared during the execution of the sorting algorithm.\n        Once the sort is finished, the bars will turn from <span style = \"color: cyan;\"> <strong>cyan</strong></span> to <span style = \"color: chartreuse;\"> <strong>chartreuse</strong></span>! \n        <br>\n        <br> If you are interested in the runtime and code for each sorting algorithm, click on its respective info button located to its left.\n        There, you will find a high-level description, the best, average, and worst case runtimes with analysis, and the implementation code in JavaScript.\n        <br>\n        <br>\n        Feel free to use the \"Sorting Speed\" bar at the top, beside the \"Scramble!\" button. Move to the right to increase speed, and move to the left to decrease speed. If you accidentally\n        decreased the speed too much, just click on the \"SORTING ALGORITHMS VISUALIZER\" title to refresh the page!\n        <p><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: auto;\" src=\"https://i.imgur.com/9YYF0Zs.png\" alt=\"\" width=\"205\" height=\"135\" /></p>\n        <p>&nbsp;</p>\n        `;\n        break;\n      }\n\n      case 4: {\n        document.getElementById(\"helpMenu-content\").innerHTML =\n          this.HTMLHelper(MAXSLIDE) +\n          `<h2 style= \"margin-top: -0.3em;\"> Summary of Sorting Algorithms </h2>\n        <ol style = \"text-align: left; line-height: 1.05em\">\n          <li><strong>Bubble Sort</strong> - Simply checks adjacent pairs, and swaps if necessary. During each iteration, bubbles the largest value to the end of the array.</li>\n          <li><strong>Selection Sort</strong> - Finds the minimum value in the entire array[0...n-1], and places it at the beginning. Repeat for the sub array[1...n-1] until sub array has only the last element.</li>\n          <li><strong>Insertion Sort</strong> - How you sort cards in your hand. Compare until you find where each value belongs among the previous elements. </li>\n          <li><strong>Merge Sort</strong> - A Divide and Conquer algorithm, where you split the array in half and sort them recursively with Merge Sort, and then merge both sorted half arrays into one sorted array. </li>\n          <li><strong>Heap Sort</strong> - Uses a Heap data structure. Given an array, we make it into a max Heap, and then remove the root node each time and place it at the end of the array.</li>\n          <li><strong>Quick Sort</strong> - Another Divide and Conquer algorithm. We partition the array into elements less than and greater than a certain pivot, and then sort the elements less and greater than the pivot recursively with Quick Sort. </li>\n          <li><strong>Cocktail Shaker Sort</strong> - Aka Bidirectional Bubble Sort. Same thing as Bubble Sort, but we Bubble Sort going left to right, and also right to left. </li>\n          <li><strong>Shell Sort</strong> - A variant of Insertion Sort. We insertion sort by \"gaps\", aiming to improve on the pitfalls of Insertion Sort, which is slow when we need to insert an element far away. </li>\n          </ol>`;\n        break;\n      }\n\n      case 5: {\n        document.getElementById(\"helpMenu-content\").innerHTML =\n          this.HTMLHelper(MAXSLIDE) +\n          `<h2 style= \"margin-top: -0.3em;\"> Last Words </h2>\n          <p> We hope you have fun with this application. Please feel free to contact any of us for feedback on the application. You\n          can also check out our Github source code at <a href = \"https://github.com/ryanliu18/Sorting-Visualizer\" target=\"_blank\">Sorting Algorithms Visualizer</a> </p>          \n          <table style=\"height: 227px; margin-left: auto; margin-right: auto; width: 552px;\">\n          <tbody>\n          <tr>\n          <td style=\"width: 179px;\"><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://i.ibb.co/jgZ7fF9/81928054-601968013933600-5665482190398423040-n.jpg\" alt=\"\" width=\"130\" height=\"147\" /></td>\n          <td style=\"width: 199px;\"><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://i.imgur.com/X6ou3Ig.png\" alt=\"\" width=\"152\" height=\"152\" /></td>\n          <td style=\"width: 157px;\"><img style=\"display: block; margin-left: auto; margin-right: auto;\" src=\"https://i.ibb.co/V9qg42q/Eric-Kuo-UBC-Card.jpg\" alt=\"\" width=\"110\" height=\"147\" /></td>\n\n          </tr>\n          <tr>\n          <td style=\"width: 179px; text-align: center;\"><a href=\"https://www.linkedin.com/in/ryan-liu18/\" target = \"_blank\">LinkedIn Ryan Liu</a></td>\n          <td style=\"width: 199px; text-align: center;\">&nbsp;</td>\n          <td style=\"width: 157px; text-align: center;\"><a href=\"https://www.linkedin.com/in/eric-k-1198b6192/\" target = \"_blank\">LinkedIn Eric Kuo</a></td>\n          </tr>\n          </tbody>\n          </table>\n        `;\n        break;\n      }\n\n      default:\n        break;\n    }\n\n    var prevBtn = document.getElementById(\"Prev\");\n    var nextBtn = document.getElementById(\"Next\");\n    if (slideNumber === MINSLIDE) {\n      prevBtn.style.backgroundColor = \"lightgrey\";\n      prevBtn.disabled = true;\n    } else if (slideNumber === MAXSLIDE) {\n      nextBtn.disabled = true;\n      nextBtn.style.backgroundColor = \"lightgrey\";\n    } else {\n      console.log(\"reached here\");\n      prevBtn.disabled = false;\n      prevBtn.style.backgroundColor = \"hsl(214, 100%, 70%)\";\n      nextBtn.disabled = false;\n      nextBtn.style.backgroundColor = \"hsl(214, 100%, 70%)\";\n    }\n  }\n\n\n  HTMLHelper(MAXSLIDE) {\n    return (\n      `<p> ` +\n      slideNumber +\n      `/` +\n      MAXSLIDE +\n      `<p>\n  `\n    );\n  }\n\n  updateSlider(){\n    \n    var slider = document.getElementById(\"myRange\");\n    var sliderValue = document.getElementById(\"sliderValue\");\n    if(isRunning){\n      slider.value = DEFAULT_VALUE;\n    } \n    slider.value = slider.value;\n    DEFAULT_VALUE = slider.value;\n\n    // sliderValue.innerHTML = `Speed: `+((slider.max-slider.value).toFixed(2))+`x`\n    sliderValue.innerHTML = `Speed: `+slider.value+`x`\n    console.log(slider.value);\n  }\n\n  \n\n    render() {\n        const{array} = this.state;\n\n        return (\n        <>\n        <div className=\"title-container\">\n        <div className=\"title\" onClick={() => this.refreshPage()}>\n          Sorting Algorithms Visualizer\n        </div>\n\n        <div className=\"title-button-row\">\n\n          <button\n            id=\"info-button\"\n            className=\"info-button\"\n            onClick={() => this.openHelpMenu()}\n          >\n            {\" \"}\n            ?{\" \"}\n          </button>\n\n          <button onClick={() => this.resetArray()}> Scramble! </button>\n          </div>\n\n        <div className = \"slidercontainer\">\n          <input type=\"range\" min={MIN_VALUE} max={MAX_VALUE} step={STEP_SIZE} defaultValue = {DEFAULT_VALUE} className = \"slider\" id=\"myRange\" onChange = {()=>this.updateSlider()}></input>\n        </div>\n    <span id=\"sliderValue\" className = \"sliderValue\"> Speed: {DEFAULT_VALUE}x</span>\n            </div>\n\n        <div id=\"helpMenu\" className=\"modal\">\n          <div className=\"modal-container\">\n            <span id=\"close\" className=\"close\">\n              &times;\n            </span>\n            <div className=\"buttons-container\">\n              <div className=\"info-buttons\">\n                <button id=\"Prev\" onClick={() => this.changeText(-1)}>\n                  {\" \"}\n                  Prev{\" \"}\n                </button>\n                <button id=\"Next\" onClick={() => this.changeText(1)}>\n                  {\" \"}\n                  Next{\" \"}\n                </button>\n              </div>\n            </div>\n          </div>\n          <div id=\"helpMenu-content\" className=\"modal-content\"></div>\n        </div>\n\n        <div id=\"algo-modal\" className=\"algo-modal\">\n          <span id=\"algo-close\" className=\"algo-close\">\n            &times;\n          </span>\n          <div id=\"algo-modal-content\" className=\"algo-modal-content\"></div>\n        </div>\n\n        <div className=\"container\">\n          <div className=\"algo-btn-group\">\n            <button onClick={() => this.openAlgoMenu(0)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(1)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(2)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(3)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(4)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(5)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(6)}> &#9432; </button>\n            <button onClick={() => this.openAlgoMenu(7)}> &#9432; </button>\n          </div>\n\n            <div className = \"btn-group\">\n            <button onClick = {() => this.bubbleSort()}> Bubble Sort</button> \n            <button onClick = {() => this.selectionSort()}> Selection Sort</button> \n            <button onClick = {() => this.insertionSort()}> Insertion Sort</button> \n            <button onClick = {() => this.mergeSort()}> Merge Sort</button> \n            <button onClick = {() => this.heapSort()}> Heap Sort</button> \n            <button onClick = {() => this.quickSort()}> Quick Sort</button> \n            <button onClick = {() => this.cocktailShakerSort()}> Cocktail Shaker Sort</button> \n            <button onClick = {() => this.shellSort()}> Shell Sort</button> \n            </div>\n\n\n            <div className=\"array-container\">\n            {array.map((value,idx) => (\n                <div className = \"array-bar\" key = {idx} style = {{height: `${value}px`}}>\n                </div>\n            ))}\n\n            \n\n        </div>\n        </div>\n \n        </>\n        );\n    }\n\n\n//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\n// Returns a random integer between min (inclusive) and max (inclusive).\n getRandomInt(min,max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n \n    // From https://javascript.info/task/shuffle\n    shuffle(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n          let j = Math.floor(Math.random() * (i + 1));\n          [array[i], array[j]] = [array[j], array[i]];\n        }\n      }\n      \n\n}","export function getInsertionSortAnimations(array) {\n    const animations = [];\n\n    for (let i = 1; i < array.length; i++) {\n        let currKey = array[i];\n        let j = i-1;\n        while (j >= 0 && array[j] > currKey) {\n            animations.push([i,j]);\n            animations.push([i,j]);\n            array[j+1] = array[j];\n            animations.push([j+1,array[j]]);\n            j--;\n        }\n        animations.push([i,j+1]);\n        animations.push([i,j+1]);\n        array[j+1] = currKey;\n        animations.push([j+1,currKey]);\n    }\n\n    return animations;\n    \n}\n\nfunction insertionSort(array) {\n    // iterate over array\n    for (let i = 1; i < array.length; i++) {\n        // currKey is the element we are inserting into the previous elements\n        let currKey = array[i];\n        // initialize j to be index of element before i\n        let j = i-1;\n        // iterate until index j is out of array or array[j] <= currKey\n        while (j >= 0 && array[j] > currKey) {\n            //when array[j] > currKey, move over value at index j to index j+1\n            array[j+1] = array[j];\n            // decrement j\n            j--;\n        }\n        // j+1 is the index where we should insert currKey\n        array[j+1] = currKey;\n    }\n}","export function getBubbleSortAnimations(array) {\n\n    const animations = [];\n    var swapped = false;\n\n    for (let i = 0; i < array.length-1; i++) {\n        for (let j = 0; j < array.length-i-1; j++) {\n            animations.push([j,j+1]);\n            animations.push([j,j+1]);\n            if (array[j] > array[j+1]) {\n                animations.push(\"Swap\");\n                animations.push([j,array[j+1],j+1,array[j]]);\n                var temp = array[j];\n                array[j] = array[j+1];\n                array[j+1] = temp;\n                swapped = true;\n            }\n        }\n        if (!swapped) break;\n    }\n\n    return animations;\n\n}\n\nfunction bubbleSort(array) {\n    // iterate over array\n    for (let i = 0; i < array.length-1; i++) {\n        // iterate over remaining unsorted elements in array\n        for (let j = 0; j < array.length-i-1; j++) {\n            // compare adjacent elements, swap if out of order\n            if (array[j] > array[j+1]) {\n                var temp = array[j];\n                array[j] = array[j+1];\n                array[j+1] = temp;\n            }\n        }\n    }\n}","export function getSelectionSortAnimations(array) {\n\n    const animations = [];\n\n    for (let i = 0; i < array.length -1; i++) {\n        var min_idx = i;\n        for (let j = i+1; j < array.length; j++) {\n            animations.push([min_idx,j]);\n            animations.push([min_idx,j]);\n            if (array[j] < array[min_idx]) {\n                min_idx = j;\n            }\n        }\n        //swap value at index i with min value at index min_idx\n        animations.push(\"Swap\");\n        animations.push([min_idx,array[i],i,array[min_idx]]);\n        const temp = array[i];\n        array[i] = array[min_idx];\n        array[min_idx] = temp; \n\n    } \n    return animations;\n}\n\nfunction selectionSort(array) {\n    //iterate over array\n    for (let i = 0; i < array.length -1; i++) {\n        //initialize index of minimum value\n        var min_idx = i;\n        //iterate over remaining elements\n        for (let j = i+1; j < array.length; j++) {\n            //if we found a new minimum element, update min_idx\n            if (array[j] < array[min_idx]) {\n                min_idx = j;\n            }\n        }\n        //swap value at index i with minimum value at index min_idx\n        const temp = array[i];\n        array[i] = array[min_idx];\n        array[min_idx] = temp; \n    }\n}\n","export function getCocktailShakerSortAnimations(array) {\n    const animations = [];\n\n    let startIdx = 0;\n    let endIdx = array.length -1;\n    let swapped = true;\n\n    while(swapped) {\n        swapped = false;\n        //forward pass left to right\n        for (let i = startIdx; i < endIdx; i++) {\n            animations.push([i,i+1]);\n            animations.push([i,i+1]);\n            if (array[i] > array[i+1]) {\n                animations.push(\"Swap\");\n                animations.push([i,array[i+1],i+1,array[i]]);\n                //swap array[i] and array[i+1]\n                let temp = array[i];\n                array[i] = array[i+1];\n                array[i+1] = temp;\n                swapped = true;\n            }\n        }\n\n        if (!swapped) break;\n        swapped = false;\n\n        endIdx--;\n\n        //backward pass right to left\n        for (let i = endIdx-1; i >= startIdx; i--) {\n            animations.push([i,i+1]);\n            animations.push([i,i+1]);\n            if (array[i] > array[i+1]) {\n                animations.push(\"Swap\");\n                animations.push([i,array[i+1],i+1,array[i]]);\n                //swap array[i] and array[i+1]\n                let temp = array[i];\n                array[i] = array[i+1];\n                array[i+1] = temp;\n                swapped = true;\n            }\n        }\n\n\n        startIdx++;\n\n    }\n\n\n    \n    return animations;\n}\n\n/*\n\ncocktailShakerSort\n\nfunction cocktailShakerSort(array) {\n    let startIdx = 0;\n    let endIdx = array.length -1;\n    let swapped = true;\n\n    // if no swaps happened during backward pass, exit\n    while(swapped) {\n        swapped = false;\n        //forward pass left to right\n        for (let i = startIdx; i < endIdx; i++) {\n            // compare adjacent elements\n            if (array[i] > array[i+1]) {\n                //swap array[i] and array[i+1]\n                let temp = array[i];\n                array[i] = array[i+1];\n                array[i+1] = temp;\n                swapped = true;\n            }\n        }\n        // if no swaps occurred during forward pass, exit\n        if (!swapped) break;\n        swapped = false;\n        // decrement endIdx, since last index has \n        // the correct largest element\n        endIdx--;\n        //backward pass right to left\n        for (let i = endIdx-1; i >= startIdx; i--) {\n            // compare adjacent elements\n            if (array[i] > array[i+1]) {\n                //swap array[i] and array[i+1]\n                let temp = array[i];\n                array[i] = array[i+1];\n                array[i+1] = temp;\n                swapped = true;\n            }\n        }\n        // increment startIdx, since first index has \n        // the correct smallest element\n        startIdx++;\n    }\n}\n\n*/","export function getShellSortAnimations(array) {\n    const animations = [];\n\n    for (let gap = Math.floor(array.length /2); gap > 0; gap = Math.floor(gap/2)) {\n        console.log(gap);\n\n        for (let endIdx = gap; endIdx<array.length; endIdx++) { \n//            let temp = array[endIdx];\n\n            for (let j = endIdx; j>= gap; j -= gap) {\n                //compare array[j] and array[j-gap]\n                animations.push([j,j-gap]);\n                animations.push([j,j-gap]);\n                //swap array[j] and array[j-gap];\n                if (array[j-gap] > array[j]) {\n                    animations.push(\"Swap\");\n                    animations.push([j,array[j-gap],j-gap,array[j]]);\n                    let temp = array[j];\n                    array[j] = array[j-gap];\n                    array[j-gap] = temp;\n                } else{\n                    break;\n                }\n            }\n        }\n    }\n\n    return animations;\n}\n\n/*\n\nshellSort\n\nfunction shellSort(array) {\n    // initialize gap = floor(n/2)\n    // every iteration we divide gap by 2 and take the floor\n    // terminate when gap <= 0 (last iteration is when gap === 1)\n    for (let gap = Math.floor(array.length /2); gap > 0; gap = Math.floor(gap/2)) {\n        // perform a \"gapped insertion sort\"\n        // increment endIdx every iteration\n        for (let endIdx = gap; endIdx < array.length; endIdx++) { \n            // decrease j by gap every iteration\n            for (let j = endIdx; j>= gap; j -= gap) {\n                //compare array[j] and array[j-gap]\n                if (array[j-gap] > array[j]) {\n                    //swap array[j] and array[j-gap]\n                    let temp = array[j];\n                    array[j] = array[j-gap];\n                    array[j-gap] = temp;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n\n*/","export function displayAlgorithmInfo(info) {\n    switch (info) {\n      case 0: {\n        return  `<br> <span style = \"color: cyan; font-size: 200%;\"> <strong><u>Bubble Sort</u></strong></span> \n                <br>\n                <br/>\n                <p>This is one of the simplest sorting algorithms. We simply iterate over the array,\n                checking each adjacent pair of values and swapping them if out of order. After each iteration,\n                the largest value would have \"bubbled\" to the right, hence the name Bubble sort. Thus, at the\n                end of all iterations, the array is in sorted order.</p>\n\n                <p><strong><u> Runtime: </u> </strong></p>\n                <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n                <tr>\n                <th>Best Case</th>\n                <th>Average Case</th>\n                <th>Worst Case</th>\n                </tr>\n                <tr>\n                <th>O(n) </th>\n                <th>O(n^2)</th>\n                <th>O(n^2)</th>\n                </tr>\n                </table>\n\n                <p>Note: To get O(n) best case runtime, we need to initialize a boolean to false, and if any \n                swap occurs during the first iteration, we set it to true. If the boolean is still false, this\n                means the array is already sorted and we exit. Otherwise, continue bubble sort normally.</p>\n\n                <p> O(n^2) comes from the double for loop. You can think of this as having the following number\n                of total comparisions:\n                n + n-1 + ... + 2 + 1 = n(n+1)/2 = O(n^2).</p></p>\n\n                <p><strong><u>Code: (in JavaScript)</u></strong></p>\n                <img src=\"https://i.imgur.com/WLNFw0J.png\" alt=\"\" width=\"60%\" height=\"40%\"></img>\n                `;\n                \n      }\n  \n      case 1: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Selection Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>We simply find the minimum value in the entire array, and place it at the start. \n        We iterate this process for the remaining n-1 elements. (then n-2, n-3, ... 1 elements)\n         So after we iterate through the entire array, it is sorted.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>O(n^2) comes from the double for loop. You can think of this as having the following number\n        of total comparisions:\n        n + n-1 + ... + 2 + 1 = n(n+1)/2 = O(n^2).</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/2ToyycQ.png\" alt=\"\" width=\"50%\" height=\"43%\"></img>\n        `;\n      }\n  \n      case 2: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Insertion Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is how we sort our hand in card games. We iterate over the array, and for each\n        element at index i, we place it at some index j, where <br> 0 <= j <= i such that the sub array \n        from indices 0...i-1,i is sorted. Thus at the end of all iterations, the entire array is sorted.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(n)</th>\n        <th>O(n^2)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>O(n) best case is because if the array is already sorted, we will never enter the inner while loop,\n        so Insertion Sort is just a for loop iterating over the array. O(n^2) worst case comes from the \n        number of executions of the inner while loop, which is up to i times. (j = i-1 to j = 0) You can think of this as having the following number\n        of total comparisions:\n        1 + 2 + 3 + ... + n-1 + n = n(n+1)/2 = O(n^2). </p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/68lstzn.png\" alt=\"\" width=\"50%\" height=\"43%\"></img>\n        `;\n      }\n  \n      case 3: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Merge Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is a simple example of a Divide and Conquer algorithm. If the array has size 1, it is sorted \n        and we return it. Otherwise, we divide the array by half, and sort each half by Merge Sort. We then\n        have two individually sorted half arrays, and now we merge them into a final sorted array.</p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        </tr>\n        </table>\n\n        <p>Since Merge Sort is recursive, it can be defined by the following recurrence relation: \n        T(n) <= 2T(n/2) +cn, where T(n) is the runtime of Merge Sort on an input of size n, and c is some positive constant.\n        The 2T(n/2) comes from the two recursive calls, and the cn from the merge step. Solving this relation with\n        substitution, we see T(n) = O(nlogn) (forgive the Abuse of Notation)</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/1H7CVWu.png\" alt=\"\" width=\"55%\" height=\"45%\"></img>\n        <img src=\"https://i.imgur.com/LMvIT6E.png\" alt=\"\" width=\"55%\" height=\"80%\"></img>\n        `;\n      }\n      case 4: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Heap Sort</u></strong></span> \n        <br>\n        <br/>\n        <p> We use a binary max Heap to implement Heap Sort. A heap is a data structure that satisfies a structural property, \n        and an ordering property. A heap is a complete tree, and every parent node has value >= or <= the value of it's children nodes. \n        (depending on if max Heap or min Heap) So, in a max Heap the root node (at index 0) is the max value, and in a min Heap the root node is the min value.\n        A heap is commonly used to efficiently implement a priority queue. \n        <br>\n        <br>\n        The idea of Heap Sort, is to first make the given array into a Heap, by calling \"buildHeap\". (the first for loop)\n        After the array is a Heap, we swap the root node, which is the max value to the end of the arrayso it is now in its correct\n        place. We then call heapify on the reduced Heap to ensure it is still a Heap, so we can swap the root node again on\n        the next iteration. After n swaps, the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        </tr>\n        </table>\n        <p>Note: This is assuming distinct elements. If non-distinct elements, best case is O(n) if all elements are equal,\n        since the runtime of heapify goes from O(logn) to O(1). (since the recursive calls will never execute)</p>\n\n        <p>The first for loop (buildHeap) takes O(n) time. (since we do not call heapify of the last half of nodes, \n          which are leaves and so are already Heaps) Then, we iterate over the array and perform n calls to heapify.\n          The worst case runtime of heapify is O(logn), since a Heap is a complete tree, thus we are guaranteed a height of at\n          most logn. So the max number of recursive calls is logn, each with a constant amount of work. \n          We see the total runtime of heapSort = O(nlogn).</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/ZeA54C4.png\" alt=\"\" width=\"55%\" height=\"45%\"></img>\n        <img src=\"https://i.imgur.com/n8q8XS7.png\" alt=\"\" width=\"65%\" height=\"45%\"></img>\n        `;\n      }\n      case 5: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Quick Sort</u></strong></span> \n        <br>\n        <br/>\n        <p>This is another example of a Divide and Conquer algorithm, and is similar to Merge Sort. The general idea is to pick a pivot element,\n        and then partition all elements less than this pivot to the left of it, and all elements greater than the pivot to the right of it.\n        So, there are many versions of Quick Sort, that differ in how they select the pivot. In our implementation, we always pick the last element as \n        the pivot. After we perform this partitioning of the array, we then perform Quick Sort on the sub array to the left of the pivot,\n        and Quick Sort on the sub array to the right of the pivot. At the end, the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n        <p>Note: We can get O(n) best case for Quick Sort if we use \"three-way partition and equal keys\"</p>\n        <p>For average case, we assume the pivot will partition the array into two roughly similarly sized \"halves\". Let's say\n        for simplicity, the two \"halves\" have size upper bounded by 2n/3. \n        So, we can describe Quick Sort by the following recurrence relation: T(n) <= cn + 2T(2n/3), where c is some positive constant.\n        The cn comes from the runtime of \"partition\", and 2T(2n/3) from the two recursive calls to Quick Sort. Solving with substitution, we see\n        T(n) = O(nlogn).  </p>\n\n        <p>For worst case, this occurs when the pivot picked is always the largest or smallest element of the array.\n        Thus, one side of the partition will always be empty, reducing the efficiency of Quick Sort significantly.\n        In this case, we can model the situation by the following recurrence relation: T(n) <= cn + T(n-1) for some positive constant\n        c. T(n-1) is because we now only have one recursive call, on an array of size n-1. Solving by substitution, we see\n        T(n) = O(n^2).  \n        Alternatively, we see that the work done by partition is like n + n-1 + n-2 + ... + 2 + 1, which is = n(n+1)/2 = O(n^2) </p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/IznX2TT.png\" alt=\"\" width=\"55%\" height=\"45%\"></img>\n        <img src=\"https://i.imgur.com/fXjteJm.png\" alt=\"\" width=\"55%\" height=\"60%\"></img>\n        `;\n      }\n      case 6: {\n        return  `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Cocktail Shaker Sort</u></strong></span> \n                <br>\n                <br/>\n                <p>This is a slight modification of Bubble Sort, hence the alternative name, \"Bidirectional Bubble Sort\". There\n                are two \"passes\", the forward pass, and then the backward pass. We perform Bubble Sort on each pass, but the first pass\n                will \"bubble\" the largest element to the last index of the array, and then on the backward pass the smallest element will\n                be \"bubbled\" to the first index of the array. We increment the first index and decrement the last index, and continue this \n                process until no swaps happen, which is our termination condition as this tells us the array is sorted.</p>\n\n                <p><strong><u> Runtime: </u> </strong></p>\n                <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n                <tr>\n                <th>Best Case</th>\n                <th>Average Case</th>\n                <th>Worst Case</th>\n                </tr>\n                <tr>\n                <th>O(n) </th>\n                <th>O(n^2)</th>\n                <th>O(n^2)</th>\n                </tr>\n                </table>\n\n                <p>Runtimes are exactly the same as for Bubble Sort. Note: implementation below contains the \"swapped\"\n                boolean necessary for O(n) best case runtime.</p>\n\n                <p><strong><u>Code: (in JavaScript)</u></strong></p>\n                <img src=\"https://i.imgur.com/uL2Xgql.png\" alt=\"\" width=\"40%\" height=\"74%\"></img>\n                `;\n      }\n      case 7: {\n        return `<br><span style = \"color: cyan; font-size: 200%;\"> <strong><u>Shell Sort</u></strong></span> \n        <br>\n        <br/>\n        <p> This is a variation on Insertion Sort. It is essentially trying to speed up Insertion Sort, since\n        insertion sort is slow when you are inserting an item far away from where it belongs. In Shell Sort, we start off by \"gap insertion sorting\" elements,\n        with a \"gap\" distance away from each other. We progressively decrease this gap using a gap sequence. \n        There are many different ways to choose gap sequences. We use a simple \n        floor(n/2), floor(n/4), ... , 1 gap sequence for simplicity. There exist more optimal gap sequences. \n        But, all gap sequences must end with 1, so that we perform Insertion Sort \n        at the very last iteration, guaranteeing the array is sorted.\n        </p>\n\n        <p><strong><u> Runtime: </u> </strong></p>\n        <table style =\"width:50%\" border=\"3px solid black\" border-collapse=\"collapse\" align = \"center\">\n        <tr>\n        <th>Best Case</th>\n        <th>Average Case</th>\n        <th>Worst Case</th>\n        </tr>\n        <tr>\n        <th>O(nlogn)</th>\n        <th>O(nlogn)</th>\n        <th>O(n^2)</th>\n        </tr>\n        </table>\n\n        <p>For best case, this is when the array is sorted, and so each step in the gap sequence takes roughly n time. \n        (innermost for loop breaks after one iteration) There are logn steps in the gap sequence by definition, so the runtime\n        is O(nlogn). \n        <br>\n        <br>\n        For worst case, we know that worst case for insertion sort is O(n^2). (Assume n is a power of 2 for simplicity)\n        So for the final iteration when gap = 1, it takes at most n^2 time. For the iteration before when gap = 2, it takes at most\n        n^2/2 time. Continuing on, we get the runtime is <= n^2(1 + 1/2 + 1/4 + ... ) = 2n^2 = O(n^2)</p>\n\n        <p><strong><u>Code: (in JavaScript)</u></strong></p>\n        <img src=\"https://i.imgur.com/aM083nL.png\" alt=\"\" width=\"60%\" height=\"55%\"></img>\n        `;\n      }\n      default: {\n        return `<p>Sorry, an unexpected error occured, please refresh</p>`;\n      }\n    }\n  }","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer'\nimport './App.css';\n\nfunction App() {\n  document.title = 'Sorting';\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}